<html><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<title>Test boliglånsrente</title>
<!-- <script type="text/javascript" charset="iso-8859-1" src="FreeLoan%201.1_files/boliglandata.js"></script>  -->
<script type="text/javascript" charset="iso-8859-1" src="boliglandata.js"></script>
<!--comment>Det er en egen feed på "http://www.finansportalen.no/feed/v2/boliglansrenter.js" for den portable kalkulatoren. Men her er ikke
renteberegningsmetoden angitt (kalkulatoren forutsetter etterskudd). Derfor en separat feed for uttesting</comment-->
<script> 
<!--



/*      

                                                                                                            
                                                                                                            
FFFFFFFFFFFFFFFFFFFFFF                                                          LLLLLLLLLLL                                                                 
F::::::::::::::::::::F                                                          L:::::::::L                                                                 
F::::::::::::::::::::F                                                          L:::::::::L                                                                 
FF::::::FFFFFFFFF::::F                                                          LL:::::::LL                                                                 
  F:::::F       FFFFFFrrrrr   rrrrrrrrr       eeeeeeeeeeee        eeeeeeeeeeee    L:::::L                  ooooooooooo     aaaaaaaaaaaaa  nnnn  nnnnnnnn    
  F:::::F             r::::rrr:::::::::r    ee::::::::::::ee    ee::::::::::::ee  L:::::L                oo:::::::::::oo   a::::::::::::a n:::nn::::::::nn  
  F::::::FFFFFFFFFF   r:::::::::::::::::r  e::::::eeeee:::::ee e::::::eeeee:::::eeL:::::L               o:::::::::::::::o  aaaaaaaaa:::::an::::::::::::::nn 
  F:::::::::::::::F   rr::::::rrrrr::::::re::::::e     e:::::ee::::::e     e:::::eL:::::L               o:::::ooooo:::::o           a::::ann:::::::::::::::n
  F:::::::::::::::F    r:::::r     r:::::re:::::::eeeee::::::ee:::::::eeeee::::::eL:::::L               o::::o     o::::o    aaaaaaa:::::a  n:::::nnnn:::::n
  F::::::FFFFFFFFFF    r:::::r     rrrrrrre:::::::::::::::::e e:::::::::::::::::e L:::::L               o::::o     o::::o  aa::::::::::::a  n::::n    n::::n
  F:::::F              r:::::r            e::::::eeeeeeeeeee  e::::::eeeeeeeeeee  L:::::L               o::::o     o::::o a::::aaaa::::::a  n::::n    n::::n
  F:::::F              r:::::r            e:::::::e           e:::::::e           L:::::L         LLLLLLo::::o     o::::oa::::a    a:::::a  n::::n    n::::n
FF:::::::FF            r:::::r            e::::::::e          e::::::::e        LL:::::::LLLLLLLLL:::::Lo:::::ooooo:::::oa::::a    a:::::a  n::::n    n::::n
F::::::::FF            r:::::r             e::::::::eeeeeeee   e::::::::eeeeeeeeL::::::::::::::::::::::Lo:::::::::::::::oa:::::aaaa::::::a  n::::n    n::::n
F::::::::FF            r:::::r              ee:::::::::::::e    ee:::::::::::::eL::::::::::::::::::::::L oo:::::::::::oo  a::::::::::aa:::a n::::n    n::::n
FFFFFFFFFFF            rrrrrrr                eeeeeeeeeeeeee      eeeeeeeeeeeeeeLLLLLLLLLLLLLLLLLLLLLLLL   ooooooooooo     aaaaaaaaaa  aaaa nnnnnn    nnnnnn


FREELOAN  - loan functions made for Finansportalen.no by Jon Erland Madsen. 







¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤
¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤
<<<<<<< ++++|++++ >>>>>>        DERVIATION OF FORMULAS USED IN FREELOAN                     <<<<<<< ++++|++++ >>>>>>
¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤
¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤



¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤
//////////////////////////      DERVIATION OF FORUMLA FOR THE PRESENT VALUUE OF A SERIAL LOAN           ////////////////////////
¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤


SERIAL LOAN

A serial loan is a loan for which the debt is repaid in equal installments on each interest due date. As the outstanding debt decreases 
throughout the maturity of the loan, the interest payments, and hence the overall payments, get lower for each due date.


THE PLAN

First, we dervie the formula for the present value of a serial loan. Then we transform this formula to a function that we can differentiate.
The differentiate function is used during the iterations we have to undertake in order to compute the interest rate.


THE PRESENT VALUTE

During the derivation, we use these symbols:

l =     net loan received by the borrower  - (what the borrower actually receives might be different from the booked principal)
i =     the index of the actual term
n =     the number of loan terms
r = nominal interest rate per term
e =     effective interest rate per term
f =     fee paid every term/due date
s =     sum start fees / orginations fees (paid at the start of the loan period)
a =     installment per term. In a serial loan, this amount is the same for each term


Installment each term is computed from the gross principal - the amount that the borrower initially receives plus eventual start fees:


    a = (l+s)/n 


Each due date, we pay this installment plus interest on the outstanding debt plus eventual periodical fee. Here, for term number 'i':


    a + a*(n-i+1)*r + f


In order to compute the present value of this payment, we must divide by a discount factor that contains the effective interest rate, 'e'.

When the interest rate is written as decimal rate (5% written 0,05), the discount factor could be written:


    (1+e)


The discounted payment for period 'i', thus, is:


    (a + a*(n-i+1)*r + f) / (1+e)^i


For simpler notation, we introduce the help symbol 'k':


    k = 1/(1+e)


The payment on due date number 'i', thus:


    (a + a*(n-i+1)*r + f)*k^i


The present value of all the periodical payments is: 


    PV = (a + t + a*(n-1+1)*r)*k^1 + (a + t + a*(n-2+1)*r)*k^2 +...+ (a + t + a*(n-n+1)*r)*k^n


Generally, the present value of payment number 'i':


    (a + t + a*(n-i+1)*r )*k^i


As payments are made at the end of each term, so that interest is accumulated before the payment, there is no payment in 
period zero. Ther first payment is at the end of period one. Thus, we sum up all the payments from i = 1 until i = n:


    PV = ∑ (a + t + a*(n-i+1)*r )*k^i


Could be written:


    PV =( ∑ (a+t)*k^i) + (a * r *∑(n-i+1)*k^i)
    

The first expression after the equal sign is a geometric progression (the nominal installment and the fee is the same in all terms). The last 
expression is not, as 'i' changes from term to term. But we can still rearrange a little:


    PV = (∑ (a+t)*k^i)  + (a * r *∑n*k^i) + (a * r * ∑(-i+1)*k^i) 


We are going to perform iterations, where we compute the present value of the sequence for a number of guesses on the discount factor 'k'. 
(Our ultimate goal is to find the effective interest rate, easily found when we know 'k'). As the formula looks now, we would have to 
compute every term of the loan. Neither could we differentiate a function with the sum sign ∑, so that Newton's method (more on that later) 
would not be immediately applicable. Hence, we will try try to get rid of the ∑s.


The two first of the three expressions to the right of the equal sign are geometric progressions. The third, we shall develop a little further:


    (a * r * ∑(i+1)*k^i)


Someone walking this path before, discovered that this expression has common features with the power rule for differentiation:


|*******************************************************************************|
|                                       |
|   RULE FOR DIFFERENTIATION OF (k^i)':                 |
|                                       |
|   (k^i)' = i*k^(i-1)                          |
|                                       |
|   (http://en.wikipedia.org/wiki/Power_rule)               |
|                                       |
|_______________________________________________________________________________|


Thus (k^(i+1))' = (i+1)*k^i


In order to benefit from this, we must rearrange the present value expression above:


    PV = (∑ (a+t)*k^i)  + (a * r *∑n*k^i) + (a * r * ∑(-i+1)*k^i) 


The last term:


    (a * r * ∑(-i+1)*k^i) = - (a * r * ∑(i-1)*k^i)      // Extracted -1


    (a * r * ∑(i-1)*k^i) = (a * r * ∑(i+1)*k^i) - (a * r * ∑2*k^i)  // (i+1) = (i-1) + 2


    (a * r * ∑(-i+1)*k^i) = (a * r * ∑2*k^i) - (a * r * ∑(i+1)*k^i)


The present value of a series of payments thus becomes:


    PV = (∑ (a+t)*k^i)  + (a * r *∑n*k^i)  + (a * r * ∑2*k^i) - (a * r * ∑(i+1)*k^i) 


The last term now equals the differential of another term - conf. the rule above: f(x) = y^n -> f'(x) = n*y^(n-1)


    (a * r * ∑(i+1)*k^i) = a * r * ∑(k^(i+1))'


Furthermore, if we look at the the right hand side, we can swap derivation and summation:


    a * r * ∑(k^(i+1))' = a * r * (∑k^(i+1))'



|*******************************************************************************|
|                                       |
|                                       |
|   FORMULA FOR ∑k^(i+1) -  (THE SUM OF A SPECIAL GEOMETRIC PROGRESSON)     |
|                                       |
|   Inside the sum sign, we now have a geometric progression. Summed from   |
|   i = 1 until i = n  it looks like this:                  |
|                                       |
|           sum = ∑k^(i+1)                      |                                       |
|                                       |
|       I   sum = k^2 + k^3 + ... + k^(n + 1)           |
|                                       |
|   We form a new progression by multiplying all terms by k:        |
|                                       |
|       II  sum) * k = k^3 + k^4 +... + k^(n + 2)           |
|                                       |
|   We subtract I fra II:                           |
|                                       |
|       II - I  sum * k - sum = k^(n + 2) - k^2             |
|                                       |
|       II - I  (k - 1) * sum = k^(n + 2) - k^2             |
|                                       |
|           sum = (k^(n + 2) - k^2) / (k - 1)           |   
|                                       |   
|           ∑k^(i+1) = (k^(n + 2) - k^2) / (k - 1)          |   
|                                       |
|                                       |
*********************************************************************************


Now, we combine three expressions. First, the original sequence:


    I   PV = (∑ (a+t)*k^i)  + (a * r *∑n*k^i)  + (a * r * ∑2*k^i) - (a * r * ∑(i+1)*k^i)

The last term in the expression can be written as the derived of another function:

    II  ∑(i+1)*k^i = (∑k^(i+1))'

We can swap the content of the right hand paranthesis with the sum formula we just derived:

    III (∑k^(i+1))' = ((k^(n+2) - k^2) / (k-1))'    

The right hand side of III is a quotient - one function of 'k' divided by another. We perform the differentiation according to the rules 
for the differentiation of a quotient:



|*******************************************************************************|
|                                       |
|   RULE FOR DIFFERENTIATION OF QUOTIENT                    |
|                                       |
|   f(x) = t/n                              |
|                                       |
|   f(x)' = (t'*n - t*n')/ n^2                      |
|                                       |
|   (http://en.wikipedia.org/wiki/Quotient_rule)                |
|                                       |
*********************************************************************************



    III     (∑k^(i+1))' = ((((n+2)*k^(n+1) - 2*k)*(k-1)) - (k^(n+2) - k^2)) / (k-1)^2 


We can now insert this expression into the expression for the present value of the whole sequence:


    I + III PV = (∑ (a+t)*k^i)  + (a * r *∑n*k^i)  + (a * r * ∑2*k^i) - (a * r * ((((n+2)*k^(n+1) - 2*k)*(k-1)) - (k^(n+2) - k^2)) / (k-1)^2 ) 


The sum signs in the first parantheseses could be replaced with the formula for the sum. We will again make at taylormade version of this:



|*******************************************************************************|
|                                       |
|   FORMULAS FOR THE SUM OF THREE SPECIAL GEOMETRIC PROGRESSONS     |
|                                       |
|                                       |
|   For ∑ (a+t)*k^i:                            |
|                                       |
|   ∑ (a+t)*k^i is a geometric progression. Summed up from i = 1 until      |
|   i = n, it looks like this:                      |
|                                       |
|           sum = ∑(a+t)*k^i                    |
|                                       |
|       I   sum = (a+t)*k^1 + (a+t)*k^2 + ... + (a+t)*k^n       |
|                                       |
|   We create a new progression by multiplying all terms in I by 'k':   |
|                                       |
|       II  sum * k = (a+t)*k^2 + (a+t)*k^3 +... + (a+t)*k^(n + 1)| |
|                                       |
|   We subtract II from I:                          |
|                                       |
|       II - I  sum * k - sum = (a+t)*k^(n + 1) - (a+t)*k       |
|                                       |
|       II - I  (k - 1) * sum = (a+t)*(k^(n + 1) - k)           |
|                                       |
|           sum = (a+t)*(k^(n + 1) - k) / (k - 1)           |
|                                       |
|                                       |
|   For a*r*∑n*k^i:                             |
|                                       |
|   For the second sum sign, a*r*∑n*k^i, the formula correspondingly is:    |
|                                       |
|           sum = a*r*n*(k^(n + 1) - k) / (k - 1)           |
|                                       |
|                                       |
|   For a*r*∑2*k^i:                             |
|                                       |
|   For the third sum sign, a*r*∑2*k^i, the formula becomes:        |
|                                       |
|           sum = a*r*2*(k^(n + 1) - k) / (k - 1)           |
|                                       |
|                                       |
*********************************************************************************

    
We insert these too into I + III and get the dream expression:


    PV = ((a+t)*(k^(n + 1) - k) / (k - 1))  + a * r * n *(k^(n + 1) - k) / (k - 1) + a * r *2*(k^(n + 1) - k) / (k - 1) - (a * r * ((((n+2)*k^(n+1) - 2*k)*(k-1)) - (k^(n+2) - k^2)) / (k-1)^2) 


Rearranged:


    PV = (((a + t) + a * r * (n + 2)) * (k^(n + 1)-k)/(k - 1)) - (a * r *((((n + 2)*k^(n + 1) - 2*k)*(k - 1)) - (k^(n + 2) - k^2)) / (k - 1)^2) 




|********************************************************************************************************************************************************
|                                                                           |
|   THE PRESENT VALUE OF A SERIAL LOAN                                                      |
|                                                                           |
|   PV = (((a + t) + a * r * (n + 2)) * (k^(n + 1)-k)/(k - 1)) - (a * r *((((n + 2)*k^(n + 1) - 2*k)*(k - 1)) - (k^(n + 2) - k^2)) / (k - 1)^2)     |
|                                                                           |
|                                                                           |
*********************************************************************************************************************************************************


The beauty within this ugliness, is that the summation sign ∑ is gone. The computer finds 'PV' in a wink. The function is also differentiable.



NEWTON'S METHOD - THE TANGENT LINE POINTS IN THE GENERAL DIRECTION OF THE TARGET

IN the forumula above, 'k' is the only unknown. The other variables should transpire from the bank's price list. No formula can give the discount 
rate 'k' directly. We have to make a guess as to what 'k' might be, compute the present value given that guess, compare the resulting present value 
to the original loan that we received and make a new guess for 'k', thus gradually narrowing the solution area.

The problem might be viewed as a function line in a chart with 'k' on one axis and 'PV' on the other. But our function is "uni-directional". We
can compute 'PV' when we know 'k', but not the other way around. We have to move 'k' back and forth along its axis until we hit 'PV' with the 
exactness we want. If we envisage this as a mechanical, two dimentional system, we would achieve this pretty quick. But the best mathematical method
was made by Newton. It is described in Wikipedia, where there is also (in 2013) a very good animated illustration of the method:

http://en.wikipedia.org/wiki/Newton%27s_method

(Although the method is strikingly simple, almost self-evident, it achives an satisfactory accuracy within normally only 4 iterations. Other methods,
as dividing the possibility area in two, deciding within wich half the answer will reside, and repeating this, normally requires 20-40 iterations
to reach the same excactness).

To use Newton's method, we first must transform the formula above, that is valid only for one 'k', into a continous function. Thereafter, we 
will differentiate this function.



    PV = (((a + t) + a * r * (n + 2)) * (k^(n + 1)-k)/(k - 1)) - (a * r *((((n + 2)*k^(n + 1) - 2*k)*(k - 1)) - (k^(n + 2) - k^2)) / (k - 1)^2)  

    f(k) =  (((a + t) + a * r * (n + 2)) * (k^(n + 1)-k)/(k - 1)) - (a * r *((((n + 2)*k^(n + 1) - 2*k)*(k - 1)) - (k^(n + 2) - k^2)) / (k - 1)^2)  - PV


So exactly what is our 'PV'? It is the sum we actually walked out of the bank with the day we took up the loan. Often, the bank will write another 
amount in its papers - the difference might be fees - but that is irrelevant here. In order to find the effective interest rate, We are only 
interested in what you actually payed and what you actually received. We call the sum you rreceived 'loan_net':


    f(k) =  (((a + t) + a * r * (n + 2)) * (k^(n + 1)-k)/(k - 1)) - (a * r *((((n + 2)*k^(n + 1) - 2*k)*(k - 1)) - (k^(n + 2) - k^2)) / (k - 1)^2) - loan_net


The effective interest rate is "hidden" within 'k'. Hence, we differentiate with respect to 'k'. Some algebra might follow:


    f(k) =  (((a + t) + a * r * (n + 2)) * (k^(n + 1)-k)/(k - 1)) - (a * r *((((n + 2)*k^(n + 1) - 2*k)*(k - 1)) - (k^(n + 2) - k^2)) / (k - 1)^2) - loan_net


    The expression is big, and we will differentiate the three terms to the right of the equal sign seperately. We shall name The two 
    first, that contain 'k', 'f1(k)' og 'f2(k)':


        f(k) = f1(k) + f2(k) - loan_net

        f(k)' = f1(k)' + f2(k)' // The differentiated constant 'loan_net' equals zero

        f1(k) = ((a + t) + a * r * (n + 2)) * (k^(n + 1)-k)/(k - 1)     // The first term in the expression f(k) above

        f2(k) = (a * r *((((n + 2)*k^(n + 1) - 2*k)*(k - 1)) - (k^(n + 2) - k^2)) / (k - 1)^2)  // The second term in f(k) - note the omission of the minus sign


    Both the terms f1(k) and f2(k) are quotients and must be differentiated according to the rule: 
    f(x) = t/n -> f(x)' = (t'*n - t*n')/ n^2 (http://en.wikipedia.org/wiki/Quotient_rule):  


        We identify nominator and denominater in 'f1(k)' og 'f2(k)':


        f1t(k) = ((a+t) + a* r *(n + 2))*(k^(n + 1) - k)            // Nominator first term

        f1n(k) = k - 1                              // Denominator first term

        f2t(k) = a * r *((((n + 2)*k^(n + 1) - 2*k)*(k - 1)) - (k^(n + 2) - k^2))// Nominator second term

        f2n(k) = (k-1)^2                            // Denominator second term


        The function we now call 'f2t(k)' contains a term where two functions of 'k' are multiplied with each other. Hence, we split
        'f2t(k)' in order to differentiate the parts separately:



            f2t(k) = a * r *((((n + 2)*k^(n + 1) - 2*k)*(k - 1)) - (k^(n + 2) - k^2))   

            Inside the expression, there is a product of two functions of 'k' that we will call 'P':

            P = ((n + 2)*k^(n + 1) - 2*k)*(k - 1)
            
            f2t(k) = a * r *(P - (k^(n + 2) - k^2))


            |*******************************************************************************|
            |                                       |
            |   RULE FOR DIFFERENTIATION OF PRODUCT:                    |
            |                                       |
            |   f(x) = a(k) * b(k)                          |
            |                                       |
            |   f(x)' = a(k)'*b(k) + a(k)*b(k)'                     |
            |                                       |
            |   (http://en.wikipedia.org/wiki/Product_rule)             |
            |                                       |
            *********************************************************************************

            
            P' = ((n + 1)*(n + 2)*k^n - 2)*(k - 1) + ((n + 2)*k^(n + 1) - 2*k)

            f2t(k)' = a * r *(P' - (n+2)*k^(n + 1) + 2*k)

            We put P' back in:

            f2t(k)' = a * r *(((n + 1)*(n + 2)*k^n - 2)*(k - 1) + ((n + 2)*k^(n + 1) - 2*k) - (n+2)*k^(n + 1) + 2*k)

    
        Then, we differentiate the four sub-functions:


    
            f1t(k) = ((a+t) + a* r *(n + 2))*(k^(n + 1) - k)            // Nominator first term

            f1n(k) = k - 1                              // Denominator first term

            f2t(k) = a * r *((((n + 2)*k^(n + 1) - 2*k)*(k - 1)) - (k^(n + 2) - k^2))// Nominator second term

            f2n(k) = (k-1)^2                            // Denominator second term



            f1t(k)' = ((a+t) + a * r * (n + 2)) * ((n+1)*k^n - 1)

            f1n(k)' = 1

            f2t(k)' = a * r *(((n + 1)*(n + 2)*k^n - 2)*(k - 1) + ((n + 2)*k^(n + 1) - 2*k) - (n+2)*k^(n + 1) + 2*k)

            f2n(k)' = 2 * (k - 1)


    Its time to reassamble the parts: 


        f(k)' = f1(k)' + f2(k)'

        f(k)' = (f1t(k)' * f1n(k) - f1t(k) * f1n(k)') / f1n(k)^2 + (f2t(k)' * f2n(k) - f2t(k) * f2n(k)') / f2n(k)^2


    We write the differentiated of the first term, f1(k)', according to the quotient rule f(x) = t/n -> f(x)' = (t'*n - t*n')/ n^2:


        f1(k)' = (f1t(k)' * f1n(k) - f1t(k) * f1n(k)') / f1n(k)^2

        f1(k)' = (((a+t) + a * r * (n + 2)) * ((n+1)*k^n - 1) * (k - 1 ) - ((a+t) + a* r *(n + 2))*(k^(n + 1) - k)) / (k - 1)^2


    The second term, f2(k)',folloowing the same recipe:


        f2(k)' = (f2t(k)' * f2n(k) - f2t(k) * f2n(k)') / f2n(k)^2

        f2(k)' = ((a * r *(((n + 1)*(n + 2)*k^n - 2)*(k - 1) + ((n + 2)*k^(n + 1) - 2*k) - (n+2)*k^(n + 1) + 2*k))*((k-1)^2) - (a * r *((((n + 2)*k^(n + 1) - 2*k)*(k - 1)) - (k^(n + 2) - k^2)))*2 * (k - 1))/(k-1)^4


And then, the whole, differentiated function:


    f(k)' = f1(k)' + f2(k)' // The general rule, but..

    f(k)' = f1(k)' - f2(k)' // .. We omitted the minus sign in front of f2(k) to make differentiation simpler. Here, it comes back:

    f(k)' = (((a+t) + a * r * (n + 2)) * ((n+1)*k^n - 1) * (k - 1 ) - ((a+t) + a* r *(n + 2))*(k^(n + 1) - k)) / (k - 1)^2 - ((a * r *(((n + 1)*(n + 2)*k^n - 2)*(k - 1) + ((n + 2)*k^(n + 1) - 2*k) - (n+2)*k^(n + 1) + 2*k))*((k-1)^2) - (a * r *((((n + 2)*k^(n + 1) - 2*k)*(k - 1)) - (k^(n + 2) - k^2)))*2 * (k - 1))/(k-1)^4


We now have a formula for the present value of a serial loan, containing all but one variable that we should be able to read directly
from the bank's price list: The effective interest rate. We can compute the effective interest rate by repeated guesses, where Newton's
method, requiering that we differentiate the formula, gives the best estimate of the next guess.

When we've found the discount factor 'k', we can compute the effective interest rate through the formula k = 1/(1+e) -> e = 1/k - 1




¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤
//////////////////////////      (END - DERVIATION OF FORUMLA FOR THE PRESENT VALUUE OF A SERIAL LOAN)           ////////////////
¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤




























¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤
//////////////////////////      DERIVATION OF A FORMULA FOR ANNUITY-IMMDEIDATE      ////////////////////////////////////////////////
¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤


ANNUITY IMMEDIATE (OR ORDINARY ANNUITIES) PAID AT THE END OF EACH PERIOD
 
"An annuity is a terminating "stream" of fixed payments, i.e., a collection of payments to be periodically made over a specified period of 
time" (Wikipedia). 

The fixed payments contain both an interest part and an installment part, but as the loan is gradually repaid on each interest due date, the 
installment share of each annuity grows and the interest share shrinks.

"If the payments are made at the end of the time periods, so that interest is accumulated before the payment, the annuity is called an 
annuity-immediate, or ordinary annuity "(Wikipedia).

The derivation below applies to ordinary annuities.


NOTATION / ASSUMPTIONS


It will be easier to read the expressions when we use the short form of the variable names:


|*******************************************************************************|
|               | Symbol        | Variable name     |
|_______________________________|_______________________|_______________________|
| Loan, original principal *    | PV            | loan          |
| Nominal, term interest rate   | r         | rate          |
| Number of payments        | n         | termnumber        |
| Periodical payment        | a         | annuity       |
|               |           |           |
|*******************************************************************************|


* The bank computes the annuity out of your original debt to the bank - the principal at the start of the loan. This might deviate
from the amount you actually receive. Fees could make up the difference. 

The present value of a loan is smaller than the sum of your payments, as a dollar paid later feels less painful than one paid now. This is why
borrowers are willing to pay more back than they receive. Lenders are willing to wait for their money, given that they receive more later.

The word "annuity" implies annual payments. But monthly payments are more common now, and "math-wise" the length of the periods is irrelevant. 
All that we demand, is that the periods have the same length (or, to be very precise - that the periodical interes rate is the same for all
periods).

If the annual interest rate is 5%, the present value of an annuity 'a' payable in one year is PV = a/1,05

The present value of this annuity plus a similar annuity payable in two years will be PV = a/1,05 + a/(1,05)^2

We use '^' as notation for "in the power of", as in Excel spreadsheets.

(This math procedure, dividing each term with a growth factor, is called "to discount").

We imagine the interest rate 'r' on decimal form, so that five percent is written 0,05. Generally, the growth factor is written '(1+r)'

We presume annuity-immediate, so that the first payment is made at the end of the first period. Hence, we have no zero term, as you
often have in Math books' examples.



ANNUITY FORMULA

We formulate the sequence of payments thus, saying that the present value is the sum of all the discounted payments. In this general 
case, we don't know exactly how many terms there are, so we leave a gap in the middle: 
 

I   PV = a/(1+r) + a/((1+r)^2) + a/((1+r)^3) + .. + a/((1+r)^n)


All terms on the right hand side have a common growth factor, '1/(1+r)'. In order to make the expressions more easy to read, we introduce 
the variable 'k':


k = 1/(1+r)

We substitue 'k' for '1/(1+r)':


I   PV = a*k + a*k^2 + a*k^3 + .. + a*k^n


We introduce a second equation, similar to the first, but where we have multiplied all terms by 'k':


II  PV*k = a*k^2 + a*k^3 + a*k^4 + .. + a*k^(n+1)


We subtract II from I. Many of the terms of the two sequences are the same and disappear. We are left with:


PV - PV*k = a*k - a*k^(n+1)


This expression can be rearranged, here with respect to the annuity 'a':

=>  PV (1 - k) = a (k - k^(n+1))

=>  PV = a (k - k^(n+1))/(1 - k)

=>  a = PV (1 - k)/(k - k^(n+1))

In javascript notation:

a = PV * (1 - k) / (k - Math.pow(k,n+1));   


WHen we subsitute the symbols for the variable names in the table above, we get:


annuity = loan * (1 - k) / (k - Math.pow(k,termnumber+1));

    



*********************************************************************************
|                                       |
|   FORMULA FOR ANNUITY-IMMEDIATE:                      |
|                                       |
|                                       |
|   annuity = loan * (1 - k) / (k - Math.pow(k,termnumber+1));      |
|                                       |
|                                       |
|   where                                   |
|                                       |
|                                       |
|   k = 1/(1+rate);                             |
|                                       |
|                                       |
*********************************************************************************





¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤
//////////////////////////      (END - DERIVATION OF A FORMULA FOR ANNUITY-IMMDEIDATE)       ///////////////////////////////////////
¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤


























¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤
//////////////////////////      DERIVATION OF A FORMULA FOR ANNUITY-DUE         ////////////////////////////////////////////////
¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤


ANNUITY-DUE - WHERE THE ANNUITIES ARE PAID IN ADVANCE - AT THE BEGINNING OF EACH PERIOD
 
For definitions, see derivation of annuity-due. The difference from annuity-immediate, is that the first period is period zero (the moment we 
receive the loan)


ANNUITY FORMULA


PV -> The present value of an annuity-due payment stream (when we compute effective interest rate, the present value is the initil size of the loan).
a  -> The annuity in an annuity-due stream
r  -> The periodic interest rate
n  -> Number of payment periods

We formulate the sequence of payments thus, saying that the present value is the sum of all the discounted payments. In this general 
case, we don't know exactly how many terms there are, so we leave a gap in the middle. The first payment shall not be discounted, as no time
has passed and no interest accured yet.

In order for the loan to run 'n' periods, since we start in period zero, the last payment happens in period 'n-1':
 

I   PV = a + a/(1+r) + a/((1+r)^2) + a/((1+r)^3) + .. + a/((1+r)^(n-1))


All terms on the right hand side have a common growth factor, '1/(1+r)'. In order to make the expressions more easy to read, we introduce 
the variable 'k':

k = 1/(1+r)

We substitue 'k' for '1/(1+r)':


I   PV = a + a*k + a*k^2 + a*k^3 + .. + a*k^(n-1)


We introduce a second equation, similar to the first, but where we have multiplied all terms by 'k':


II  PV*k = a*k + a*k^2 + a*k^3 + a*k^4 + .. + a*k^n


We subtract II from I. Many of the terms of the two sequences are the same and disappear. We are left with:


I - II  PV - PV*k = a - a*k^n


This expression can be rearranged:


=>  PV * (1 - k) = a * (1 - k^n)

=>  PV = a * (1 - k^n)/(1 - k)

=>  a = Pd * (1 - k)/(1 - k^n)


In javascript notation:


PV = a * (1 - Math.pow(k,n))/(1 - k); // (The traditional way to write the sum of a geometric progression)

a = PV * (1 - k) / (1 - Math.pow(k,n)); 



*********************************************************************************
|                                       |
|   FORMULA FOR ANNUITY-DUE:                        |
|                                       |
|                                       |
|   annuity = loan * (1 - k) / (1 - Math.pow(k,termnumber));        |
|                                       |
|                                       |
|   where                                   |
|                                       |
|                                       |
|   k = 1/(1+rate);                             |
|                                       |
|                                       |
*********************************************************************************




¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤
//////////////////////////      (END - DERIVATION OF A FORMULA FOR ANNUITY-DUE)          ///////////////////////////////////////
¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤










¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤
¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤
<<<<<<< ++++|++++ >>>>>>        (END - DERVIATION OF FORMULAS USED IN FREELOAN)                 <<<<<<< ++++|++++ >>>>>>
¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤
¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤
































¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤
¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤
<<<<<<< ++++|++++ >>>>>>        COMMON FUNCTIONS                                <<<<<<< ++++|++++ >>>>>>
¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤
¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤*/







function roundoff(number, direction, presision)
{
/*

Rounds 'nummber' according to the parameters 'presision' and 'direction':

direction =>    0, false or absent: Normal rounding rules apply 1: Rounds up 2: Rounds down
presision =>    0, false or absent: Rounds to two decimals 1: Rounds to integer

*/

var roundfact;

if (!presision || presision == 0) roundfact = 100; else roundfact = 1;

if (direction == 1) return Math.ceil(number*roundfact)/roundfact;

else if (direction == 2) return Math.floor(number*roundfact)/roundfact;

else return Math.round(number*roundfact)/roundfact;

/* END function roundoff() */}






/*¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤
¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤
<<<<<<< ++++|++++ >>>>>>        (END - COMMON FUNCTIONS)                            <<<<<<< ++++|++++ >>>>>>
¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤
¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤*/
























function freeLoan(
received,       // OBLIGATORY: The loan amount received by the borrower. (Due to fees, this might deviate from the principal in the bank's books).

// NEW IN VERSION 1.1.: (new parameter 'firstpayment')
firstpayment,       // PERIOD MODE: Either this first payment or 'numberofperiods' is obligatory. with 'firstpayment' >0, the number of periods are computed*)
numberofperiods,    // PAYMENT MODE: Either this loan time or 'firstpayment" is obligatory. With 'numberofperiods' > 0, the periodical payments (annuities) are computed.
// END - NEW IN VERSION 1.1.

periods_per_year,   // OBLIGATORY: In order to compute annual, effective interest rate, som connection to years must be made.
serial,         // 0, 'false' or omitted: Annuity loan. 'true'/'on'/1 = Serial loan.
balloon,        // 0, 'false' or omitted: Zero. Integer > 0: The planned residual value of the loan ("balloon") to be paid when the loan period is over.
interestonly_periods,   // 0, 'false' or omitted: zero. Integer > 0: The initial interest-only period wanted by the borrower
round_direction,    // 0, 'false' or omitted: Annuities are rounded after normal rules  1: Rounded up 2. Rounded down
round_presision,    // 0, 'false' or omitted: Payment rounded to nearest 1/100  1: ..rounded to nearest integer
remainder_handling, // 0, 'false' or omitted: The "global" remainder at the end of the loan period is payed / compensated with the last payment 1: ..is ignored
ignore_origination, // 0, 'false' or omitted: Origination fee added to the loan and included in the computation. 1 or true: Computation performed without origination fee **)
annuity_due,        // 0, 'false' or omitted or "immediate":  Annuity-immediate 1, "true" or "due": Annuity_due ***)
capitalization_freq,    // 0, 'false' or omitted: 12 (Capitalization 12 times a year). Integer>0: Any number of capitalizations per year.
interestonly_periods_max,// 0, 'false' or omitted: 0. Integer >= 0: The maximal interest only-period offered by the bank. In years. 
fee_processing,     // 0, 'false' or omitted: 0. Number >= 0: Processing fee: A one-time fee of a fixed sum to be payed at the beginning of the loan period.  ****)
fee_document,       // 0, 'false' or omitted: 0. Number >= 0: Document preparation fee: A one-time fee of a fixed sum to be payed at the beginning of the loan period. ****)
fee_percentage,     // 0, 'false' or omitted: 0 .Number >= 0: Percentage fee: One-time fee to be payed at the beginning of the loan period computed out of the principle (gross loan). 2 = 2%. ****)
fee_period_perc,    // 0, 'false' or omitted: No percentage fee. Integer: Percentage. Loans given as a credit line have a periodical has a fee as a percentage of principal PER PERIOD 
rate_thresholds,    // 0, 'false' or omitted: No - intial interest rate is fixed for the whole loan for the whole loan period. 1 or 'true': Rate might change *****)
rate_segments,      // 0, 'false' or omitted: No - all segments of the loan has the same interes rate. 1 or 'true': Every segment might have separate interest rates. ******)
price_storage,      // OBLIGATORY: The parmeter 'price_storage' is a two-dimentional array. It must have at least one interest rate, in 'price_storage[1][4]'. 'price_storage[0]' is not expected nor used.*******)
accuracy)       // OBLIGATORY (FOR ADMINISTRATOR) 0: Fast, inaccurate 1: Normal 2: Extremely accurate. Only for serial loans. Does not apply to annuity loans.
/*

// NEW IN VERSION 1.1.: (new parameter 'firstpayment' in this documentation)
freeLoan(received,firstpayment, numberofperiods,periods_per_year,serial,residual,interestonly_periods,round_direction,round_presision,remainder_handling,ignore_origination,annuity_due,capitalization_freq,interestonly_periods_max,fee_processing,fee_document,fee_percentage,fee_period_perc,rate_thresholds,rate_segments,price_storage,accuracy)   
// END - NEW IN VERSION 1.1.    


    
¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤
//////////////////////////      WHAT THE FUNCTION DOES:     ////////////////////////////////////////////////////////////////////////
¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤

The function computes effective annual percentage rate (EAPR) for a loan. As a side product, other values that could come useful are 
computed too. All results are returned in the array 'result', which is defined differently for serial loans and annuity loans.


The content of 'result' for an annuity loan:


result[0] -> Effective annual interest rate
result[1] -> residue: What is left of the loan in the last term due to rounding
result[2] -> The array 'interval_data', that contains:
    
    result[2][x][0] -> payment          Net periodic payment, exclusive of fees, rounded
    result[2][x][1] -> number of terms;         The number of periodic payments it takes to pay down this segment of the loan
    result[2][x][2] -> periodic fee         Practical to have here
    result[2][x][3] -> adjusted lower segment limit Since the number of periods must be and integer, you rarely hit the segment limit 
                            accurately. The next segments limits must be adjusted accordingly.
    result[2][x][4] -> upper segment limit      Normally the same as 'price_storage[step][2]', but could also be adjusted
    result[2][x][5] -> remainder;           Fractions of cents we pay to little or too much each time due to rounding

// NEW IN VERSION 1.1.:(result[3] added. 'firstpayment' explained)
result[3] -> Number of periods for payback.If the annuity - 'firstpayment' - is present, this variable should contain the number of terms.

firstpayment,       // PERIOD MODE: Either this first payment or 'numberofperiods' is obligatory. with 'firstpayment' >0, the number of periods are computed*)
numberofperiods,    // PAYMENT MODE: Either this loan time or 'firstpayment" is obligatory. With 'numberofperiods' > 0, the periodical payments (annuities) are computed.
// END - NEW IN VERSION 1.1.


The content of 'result' for a serial loan:


result[0] -> effective annual interest rate
result[1] -> remainder
result[2] -> array with one 'i' for every single payment during the whole loan period:

    result[2][i][0]  -> The whole rounded payment for period 'i', included installment and fees. 
    result[2][i][1]  -> The installment for peroid 'i'
    result[2][i][2]  -> The fee for period 'i'

// NEW IN VERSION 1.1.: (result[3] added)
result[3] -> Number of periods for payback.If the first payment - 'firstpayment' - is present, this variable should contain the number of terms.
// END - NEW IN VERSION 1.1.

The function handles three different types of loan segments:


i)      Normal: The interest rate for the whole loan is determined by the initial size of the principal when the loan is given. The rate does not 
    change during the loan period. This is the most common and the simplest model.

ii)     Thresholds: The interest rate for the whole loan changes when the principal passes certain thresholds (the parameter 
    'rate_thresholds' == true). For instance, for a loan on 1,5 million, the rate might be 3.5% until it is paid off below 1 million, 
    when the interes rate might rise to 3.75%. But there is only one rate at the time for the whole loan.

iii)    Concurrent rates: Separate segments of the loan have different interest rates at the same time. All installments are deducted from the 
    uppermost segment of the loan. This segment, thus, is payed dowm first. For instance, ther rate for the segment between 0 and 500,000 
    could be 4%, between 500,000 and 1,000,000 i could be 3.5% and above 1,000,000 it could be 3%. All applying at the same time. 
    (The parameter 'rate_segments' == true)


PARMETERS:

(See the corresponding asterisks in the parameter list at the beginning of the function):

// NEW IN VERSION 1.1.: ('firstpayment' and period mode explained)
*) One of the two parameters 'firstpayment' or 'numberofperiods' must have a value. If both have a value, 'numberofperiods' is used. Not all
values for 'firstpayment' will be big enough to encompass a down payment of the loan and will thus result in an error.

The function does not return the number of periods for loans that run with multiple, concurrent interest rates in different segments 
('rate_segments' == true). 

When there is an initial period where only interest is paid ('interestonly_periods' > 0) and the function computes periods, the interest only
periods are added to the payment time. The reason is that if it is subtracted, as is otherwise the case, the periodic payments increase in the
down payment period. Here, they would increase to an amount bigger than the user has indicated he wants as as his periodical payment.

The combination of a chosen payment/annuity and a loan that changes interest rate after thresholds are passed is possible, but almost
surrealistic. This combination will result in an error.
// END - NEW IN VERSION 1.1.

**) 'ignore_origination': Several charges could be incurred when taking a loan. These fees and charges have different names. Some are a 
percentage of the loan, some are a fixed sum. If the 'ignore_origination' variable is TRUE, these fees are ignored when computing effective 
interest rate. It is logically correct to include them ('ignore_origination' = false), but fhe function is able to do both.

***) 'annuity-due' == false implies Annuity-immediate:
Annuity-immediate (interest in arrears): Equal payments are made at the end of each period. This is the most common annuity loan model.
Annuity-due (interest in advance): Payments are made at the beginning of each period. For annuity loans, we presuppose that the whole of
the annuity is paid in advance. For serial loans, only the interest is paid in advance.

The annuity period could deviate from the payment period. For instance, the loan might have four annuities a year, but still be paid 
monthly.

****) Origination fees: There might be several one-time fees payable at the beginning of the loan period: Arrangement fee, processing fee, 
application fee, origination fee, appraisal fee, credit report fee, tax service fee, underwriting fee, document preparation fee, wire 
transfer fee, office administration fee and many others. This function allows two parameters for fees of a fixed sum, called 'fee_processing' 
and 'fee_document'. 

Together, these one-time fees are referred to as "origination fees".
firstpayment,       // ALTERNATIVELY: Either this first payment or 'numberofperiods' is obligatory. *)
numberofperiods,    // ALTERNATIVELY: Either this loan time or 'firstpayment" is obligatory. This function only computes loans that are given over whole years.

(There are normally recurring / periodical fees as well. One is in the variable 'fee_period_perc'. Others are in the array 'price_storage').

There is also a parameter for a one-time percentage fee due at the beginning of the loan period: 'fee_percentage'. This if often the case
for open credit facilities. We make the presumption that the loan is drawn to the credit limit at the start of the loan period, so that this 
percentage is simply computed from the initial principal.

*****) Normally, you are offered one interest rate for the whole loan sum for the whole loan period. But in some loan contracts the interest
rate changes when the loan is payed down beyond certain thresholds. This is signalled with 'rate_thresholds' == true.

******) Even if the interest rate might change when the principal passes certain thresholds, you normally have only one interest rate at
the time. But there are loan contracts where the loan might run with separate intrest rates in each segment. For instance, ther rate
for the segment between 0 and 500,000 could be 4%, between 500,000 and 1,000,000 i could be 3.5% and above 1,000,000 it could be 3%. All 
applying at the same time. This is the case when 'rate_segments' == true.

*******) OBLIGATORY: The parameter 'price_storage' is a two-dimentional array - a matrix. Each row in the matrix consists of four elements:

price_storage[step][1]  -> Lower limit for the rate segment #step. Omitted/empty: Interpreted as zero.
price_storage[step][2]  -> Upper limit for the rate segment #step. Omitted/empty/"Unlimited": Interpreted as indefinite.
price_storage[step][3]  -> The periodical fee for each payment in segment #step.
price_storage[step][4]  -> OBLIGATORY: The annual interest rate in the segment (as % per anno) 

At least one interest rate, expected in 'price_storage[1][4]', is obligatory.

'price_storage[0]' is not expected and not used. 

Each segment/step is defined by a lower and upper limit. Det lowest segment comes first, at 'step' == 1. We presuppose that the segments
don't overlap. 



SECTIONS

The function 'annuityLoan()'consists of seven separate, numbered sections:

1)      Preparation and adaption of data
2)  An eventual residual/balloon payment
3)      The number of periods in each interval
4)  An eventual interest-only period
5)  Global residue 
6)  Effective interest rate 
7)  Result reporting



EXTERNAL FUNCTIONS USED

In addition to the built-in fuctions of the programming language, 'freeLoan' utilizews two main external functions:

function serialLoan()
function annuityLoan()

// NEW IN VERSION 1.1.:
The latter uses three subfunctions:
function termnum_annu()
// END - NEW IN VERSION 1.1.

function intervallength()
function intervallength_separate()

Both use

function roundoff()



ERRORS


When an error is encountered - illegal parameter values, missing convergence, division with zero etc - no array is returned. Instead, the 
function returns a single, negative integer, -1, -2, -3 etc. Errors can thus be caught with the function Array.isArray(obj).


-1: Longer interest-only period requested than the bank offers.
-2: First segment in the obligatory parameter array 'price_storage' undefined
-3: The requested residual/balloon smaller than the smallest laon amount offered
-4: The requested residual/balloon bigger than the biggest laon amount offered
-5: No interval detected  (normally because the loan amount is too big or too small) 
-6: NO convergence, for instance due to zero loan periods or -100% nominal interest rate 
-7: Combination not supported: FreeLoan dose not support concurrent, separate interest rates and annuities in advance.
-8: Too small periodic payment: If the user has chosen a payment too small to pay down the loan.
    
Negative interest rates are still possible, but they are then returned in the result array 'res'.



TERMINOLOGY

These terms will be encoutered through FreeLoan:

"Principal": The remaining debt at any point during the loan period. The principal at the beginning of the loan period might differ from the 
amount the borrower receives, as the bank might add fees to the debt. (Some sources define the principal only as the size of the intital loan).

"Installment": A payment that dimishes the principal during the loan period. (Some sources use this term for all payments, including interest.
Here, only down payments of the principal are meant).

"Term": A regular payment, normally composed of installment, interest rate and fees, made by the borrower after taking the loan.

"Received": The money the borrower actually receives when taking a loan. This might be lower than the debt booked with the bank. Fees make
out the difference.

"Loan period": The period from the loan is taken until it has been completely paid back. 

"Capitalization": The process of computing accrued interest and fees. Normally, the bank will do this at all agreed payment dates. In that
case, the capitalization frequency is the same as the payment frequency. But sometimes they are not. For instance, quarterly capitalization 
and monthly payments are not unusual.

"Segment": A 'segment' is a part of a loan currently running with a certain interest rate. For example the part of the loan between one and
two millions when this is the upper and lower limits for a rate step.

"Interval": An 'interval' is a period in time, for example the number of periods it takes for the principal to be payed down from one segment
threshold to the next. 

In the simplest and most common loans, there is only one segment and one interval.



THE PLAN

Most indata checks are performed here in the main function. Then one of the two main sub functions, function serialLoan() or 
function annuityLoan() are called. They return the results in an array.


INPUT CONTROL PRIOR TO CALLING FREELOAN

The combination of an initial interest free period and running the calculator in period mode might produce absurd results, for instance
payback periods of thousands of years. So this combination should be avoided.


¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤
//////////////////////////      1) PREPARATION AND ADAPTION OF DATA:              //////////////////////////////////////////////
¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤

*/

{

/* INNDATA CONTROL - ERRORS CAUSING INTERRUPTION

Indata control are pressupposedly performed outside of the function. But also a little here. If the the customer wants a longer period when 
he only pays interest than the bank offers, the error number -1 is returned: */

    
    if (interestonly_periods && interestonly_periods>0) // The user wishes a period where only interest is payed
        {

        if (!interestonly_periods_max || interestonly_periods > interestonly_periods_max) {
            resultAsJSON += getErrorResultJSON(-1);
            return -1;
        }

        }


// The parameter 'price_storage' is an array. It must have at least one element: 


    if (price_storage.length < 1 ) {
        resultAsJSON += getErrorResultJSON(-2);
        return -2;
    }


// We convert en empty 'remainder_handling' to zero:


    if (!remainder_handling || isNaN(remainder_handling)) remainder_handling = 0;


//  We convert an enventual empty residual to zero.. */


    if (!balloon || isNaN(balloon)) balloon = 0;


// .. and return an error number if the requested residual/ballon payment is smaller than the smallest loan offered by the bank:


    if (balloon < price_storage[1][1]) {
        resultAsJSON += getErrorResultJSON(-3);
        return -3;
    }


// We also return an error value if the residual/ballon payment is bigger than the upper limit of the loan product:  */


    if (price_storage[price_storage.length-1][2] > 0 && balloon > price_storage[price_storage.length-1][2]) {
        resultAsJSON += getErrorResultJSON(-4);
        return -4;
    }


/* If we - while searching through 'price_storage' - don't find any loan segment, we return error number -5

The annity formula we use will produce division by zero if the number of periods are zero or the nominal periodical interest rate is

-100%. We call this a "convergence error" and it is given the error number -6 


Freloan is not able to compute the effecive interest rate for a loan running with different interest rates at the same time if 
the loan is an annuity loan with annuity-due - annuities in advance. When 'rate_segments == true', 'annuity_due == true' and 
'serial == false' at the same time, error code -7 is returned. (IMPORTANT: To avoid hundreds of error messages, this test should ideally 
be performed before calling FreeLoan) 

    
We first verify the parameters: */

    if (!annuity_due || annuity_due == "" || annuity_due == 0) annuity_due = false; else annuity_due = true;

    
    if (!rate_segments || rate_segments == "" || rate_segments == 0) rate_segments = false; else rate_segments = true;

    
    if (!serial || serial == "" || serial == 0) serial = false; else serial= true;


    if (rate_segments && annuity_due && !serial) {
        resultAsJSON += getErrorResultJSON(-7);
        return -7;
    }


// NEW IN VERSION 1.1.:
/* Correspondingly, FreeLoan does not support the combination of a user chosen periodic payment and loan models where different interest
rates run in concurrent loan segments: */

    if (!isNaN(firstpayment) && firstpayment != 0 && rate_segments) {
        resultAsJSON += getErrorResultJSON(-9);
        return -9;
    }
// END - NEW IN VERSION 1.1.


/* DATA IN A FORMAT SUITABLE FOR OUR FORMULAS:


The function uses a default capitalization frequency of 12 (monthly) - although an error message might be more appropriate.. */


    if (!capitalization_freq || capitalization_freq == "" || capitalization_freq == 0)  capitalization_freq = 12;


// The result is returned in the array 'result':
// NEW IN VERSION 1.1.: Parameter 'firstpayment' added. Direct 'return' of function result.


    if (isNaN(serial) == false && serial != false && serial != 0) {
        result = serialLoan(received,firstpayment,numberofperiods,periods_per_year,balloon,interestonly_periods,round_direction,round_presision,remainder_handling,ignore_origination,annuity_due,capitalization_freq,interestonly_periods_max,fee_processing,fee_document,fee_percentage,fee_period_perc,rate_thresholds,rate_segments,price_storage,accuracy);    
        //resultAsJSON += getSerialResultJSON(result);
    } else {
        result = annuityLoan(received,firstpayment,numberofperiods,periods_per_year,balloon,interestonly_periods,round_direction,round_presision,remainder_handling,ignore_origination,annuity_due,capitalization_freq,interestonly_periods_max,fee_processing,fee_document,fee_percentage,fee_period_perc,rate_thresholds,rate_segments,price_storage);
        //resultAsJSON += getAnnuityResultJSON(result);
    }
    
// END - NEW IN VERSION 1.1.

    return result;

/* END freeLoan() */}



























/*¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤
¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤
<<<<<<< ++++|++++ >>>>>>        EFFECTIVE INTEREST RATE FOR ANNUITY LOANS                   <<<<<<< ++++|++++ >>>>>>            
¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤
¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤*/


function annuityLoan(
received,       // OBLIGATORY: The loan amount received by the borrower. (Due to fees, this might deviate from the principal in the bank's books).

// NEW IN VERSION 1.1.: 
firstpayment,       // PERIOD MODE: Either this first payment or 'numberofperiods' is obligatory. with 'firstpayment' >0, the number of periods are computed*)
numberofperiods,    // PAYMENT MODE: Either this loan time or 'firstpayment" is obligatory. With 'numberofperiods' > 0, the periodical payments (annuities) are computed.
// END - NEW IN VERSION 1.1.

periods_per_year,   // OBLIGATORY: In order to compute annual, effective interest rate, som connection to years must be made.
balloon,        // 0, 'false' or omitted: Zero. Integer > 0: The planned residual value of the loan ("balloon") to be paid when the loan period is over.
interestonly_periods,   // 0, 'false' or omitted: zero. Integer > 0: The initial interest-only period wanted by the borrower
round_direction,    // 0, 'false' or omitted: Annuities are rounded after normal rules  1: Rounded up 2. Rounded down
round_presision,    // 0, 'false' or omitted: Payment rounded to nearest 1/100  1: ..rounded to nearest integer
remainder_handling, // 0, 'false' or omitted: The "global" remainder at the end of the loan period is payed / compensated with the last payment 1: ..is ignored
ignore_origination, // 0, 'false' or omitted: Origination fee added to the loan and included in the computation. 1 or true: Computation performed without origination fee *)
advance,        // 0, 'false' or omitted: 0. Annuity-immediate 1, "true" or "due": Annuity_due **)
capitalization_freq,    // 0, 'false' or omitted: 12 (Capitalization 12 times a year). Integer>0: Any number of capitalizations per year.
interestonly_periods_max,   // 0, 'false' or omitted: 0. Integer >= 0: The maximal interest only-period offered by the bank. In years. 
fee_processing,     // 0, 'false' or omitted: 0. Number >= 0: Processing fee: A one-time fee of a fixed sum to be payed at the beginning of the loan period.  ****)
fee_document,       // 0, 'false' or omitted: 0. Number >= 0: Document preparation fee: A one-time fee of a fixed sum to be payed at the beginning of the loan period. ****)
fee_percentage,     // 0, 'false' or omitted: 0 .Number >= 0: Percentage fee: One-time fee to be payed at the beginning of the loan period computed out of the principle (gross loan). 2 = 2%. ****)
fee_period_perc,    // 0, 'false' or omitted: No percentage fee. Integer: Percentage. Loans given as a credit line have a periodical has a fee as a percentage of principal PER PERIOD 
rate_thresholds,    // 0, 'false' or omitted: No - intial interest rate is fixed for the whole loan for the whole loan period. 1 or 'true': Rate might change *****)
rate_segments,      // 0, 'false' or omitted: No - all segments of the loan has the same interes rate. 1 or 'true': Every segment might have separate interest rates. ******)
price_storage)      // OBLIGATORY: The parmeter 'price_storage' is a two-dimentional array. It must have at least one interest rate, in 'price_storage[1][4]'. 'price_storage[0]' is not expected nor used.*******)

/*

¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤
//////////////////////////      WHAT THE FUNCTION DOES:     ////////////////////////////////////////////////////////////////////////
¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤

The function computes effective annual percentage rate (EAPR) for an annuity loan. As a side product, other values that could come useful are 
computed too. All results are returned in the array 'res':


res[0] -> Effective, annual interest rate
res[1] -> Remainder: What is left of the loan at the end of the payment period, to be payed/renumerated with the last payment
res[2] -> Array with the results from the computation of loan intervals (of which there must be at least one):
    res[3][x][1] -> Annuity: The annuity of the x'th interval, rounded without periodic fee 
    res[3][x][2] -> Periods: The number of periods the x'th interval consists of
    res[3][x][3] -> Fee: The periodical fee of all payments in the x'th interval
    res[3][x][4] -> Principal: Principal at the end of the x'th interval
    res[3][x][5] -> Remainder: Remainder after rounding the annuity of the x'th interval 

// NEW IN VERSION 1.1.: 
res[3] -> Number of terms. If the parameter 'firstpayment' is present, this variable contains the number of terms it takes to pay back the loan.
// END - NEW IN VERSION 1.1.

The function handles three different types of loan segments:


i)      The interest rate for the whole loan is determined by the initial size of the principal when the loan is given. The rate does not 
    change during the loan period. This is the most common and the simplest model.

ii)     The interest rate for the whole loan changes when the principal passes certain thresholds (the parameter 'rate_thresholds' == true)

iii)    Separate segments of the loan have different interest rates at the same time. All installments are deducted from the uppermost segment 
    of the loan. This segment, thus, is payed dowm first. For instance, ther rate for the segment between 0 and 500,000 could be 4%, between 
    500,000 and 1,000,000 i could be 3.5% and above 1,000,000 it could be 3%. All applying at the same time. 
    (The parameter 'rate_segments' == true)


PARAMETERS:

See the corresponding definitions in the main function freeLoan()



// NEW IN VERSION 1.1.: (corrected function name)
SECTIONS IN 'annuityLoan()':
// END - NEW IN VERSION 1.1.

The function consists of seven separate, numbered sections:

1)      Preparation and adaption of data
2)  An eventual residual/balloon payment
3)      The number of periods in each interval
4)  An eventual interest-only period
5)  Global residue 
6)  Effective interest rate 
7)  Result reporting



EXTERNAL FUNCTIONS USED

// NEW IN VERSION 1.1.:
In addition to the built-in fuctions of the programming language, 'annuityloan' utilizes five external functions:
function termnum_annu()
// END - NEW IN VERSION 1.1.

function termnum_annu()
function intervallength()
function intervallength_separate()
function roundoff()



ERRORS


See the error definitions in the main function freeLoan()


THE PLAN

The interest rate is computed by iterations. Before performing the iterations, we need to know the annity and over how many periods it runs. When 
we have a loan that changes interest rate during the payment period, we could have adjacent intervals with different annuities. The function
also supports parallell interest rates. 

Hence, all the relevant annuities, number of periods and remainders are first computed and stored in the array 'interval_data'.

Generally, we use the function parmeters to compute the values in 'interval_data' before we use the values in 'interval_data' to compute the 
result(s) that will be returned in the array 'res'.



¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤
//////////////////////////      1) PREPARATION AND ADAPTION OF DATA:              //////////////////////////////////////////////
¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤

*/

{

/* 

 DATA IN A FORMAT SUITABLE FOR OUR FORMULAS:

It is mathematically correct to take all fees into consideration when computing effective interest rate. But the function also supports
the ommittance of the start/orgination fees: */
    

    var principal;

    if (ignore_origination) principal = eval(received);         
    else 
        {

        principal = (eval(received) + eval(fee_document)) * (100+fee_percentage) / 100; // What the user receives plus fees

        // Compensation for unexplained error: 'fee_processing' sometimes evaluates to 'undefined':

        if (!isNaN(eval(fee_processing))) principal +=fee_processing;

        }

// Error if the residual/ballon payment is greater than the principal: 


    if (balloon > principal) return -3;

    
/* Total number of calculation periods are the total number of periods, 'numberofperiods'  divided by 'periods_per_year' to find the number 
of years. We then multiply this by the capitalization frequency, 'capitalization_freq' to find the number of calculation periods.

*/


    var calculation_periods = numberofperiods/periods_per_year*capitalization_freq; // periods_per_year
    

// The number of intial interest-only periods (where no installments are paid):


    var installment_grace_periods = interestonly_periods/periods_per_year*capitalization_freq; 
    

// The number of "normal" periodical payments that include installment:


    var installment_periods = calculation_periods - installment_grace_periods;  


/* 'rate_divisor' is the divisor the nominal, annual interest rate must be divided by to obtain the periodic interest rate. For instance, a
nominal interest rate of 6% equals a nominal monthly decimal rate of 0,005 => 6/1200. */


    var rate_divisor = 100*capitalization_freq;


/* If the user has chosen to a periodic payment,'firstpayment', rather than the number of periods: */ 

// NEW IN VERSION 1.1.:

    if (!isNaN(firstpayment) && firstpayment != 0)
        {
        // alert(principal*price_storage[1][4]/rate_divisor);

        /* If 'firstpayment' is smaller than the interest rate part, the payment cannot service the loan: */

        if (principal*price_storage[1][4]/rate_divisor > firstpayment) return -8;

        /* If 'firstpayment' equals the interest rate part, we can service the loan only if the balloon equals the principal: */

        else

        if (principal*price_storage[1][4]/rate_divisor == firstpayment && principal != balloon) return -8;

        }


// END - NEW IN VERSION 1.1.

/* 
¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤
//////////////////////////      2) AN EVENTUAL RESIDUAL (BALLOON PAYMENT):        //////////////////////////////////////////////
¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤

The residual/balloon payment is the eventual part of the loan that is not payed back through the periodic payments, but rather through a 
"balloon" payment at the end of the loan period. 

We subtract the balloon from all segment limits before computing the annuity and the length of the payment period for each segment.

ADJUSTMENT OF SEGMENT LIMITS:

When the loan has a planned balloon, we divide it in two:

    - The balloon is treated as an interest-only loan

    - The other part of the loan is treated as an ordinary annuity loan

But by doing this, the limits for each loan segment in 'price_storage' will no longer encompass the correct loan amount. If the loan is to have a 
planned residual (balloon payment) we thus make an adjusted copy of 'price_storage' where the amount 'balloon' are subtracted from all the limit
values. 

We place these adjusted limits in a new array called 'price_storage_cop'.


*/  


    var interest_amount_res = 0;        // The interest amount for the residual (balloon) for each periodic payment

    var price_storage_cop = new Array;  // A copy of 'price_storage' with adjusted segment limits

    var principal_ann;          // The remaining principal (less balloon) to be serviced as an annuity loan

    principal_ann = principal - balloon;    

    if (balloon > 0)
        {
        
        

        var nr = 1; // 'price_storage_cop' could have fewer steps than the original 'price_storage'

        for (i=1;i<price_storage.length;i++) 
            {

            
            /* If the balloon is lower than the upper limit for the segment, or we are in the first (lower) segment - where an 
            empty value is interpreted as "unlimited" -  this is a relevant segment: */


            if (balloon <= price_storage[i][2] || price_storage[i][2]=="") 
                {

                price_storage_cop[nr] = new Array;

                if (price_storage[i][1] > balloon) price_storage_cop[nr][1] = price_storage[i][1] - balloon;
                else price_storage_cop[nr][1] = 0;
                    
                /* price_storage[i][2] is the upper limit of the segment. If it's greater than the balloon:*/

                if (price_storage[i][2] >= balloon) price_storage_cop[nr][2] = price_storage[i][2] - balloon;

                /* An empty limit is interpreted as "unlimited". We copy it over: */

                else if (price_storage[i][2] = "") price_storage_cop[nr][2] == "";

                /* A negativ upper limit is impossible. HMMMM. KAN GI GAL MATTE..? We assign it the value zero: */

                else price_storage_cop[nr][2] = 0;

                price_storage_cop[nr][3] = price_storage[i][3]; // The periodic fee is the same
                price_storage_cop[nr][4] = price_storage[i][4]; // The interest rate is the same

                    
                if (price_storage_cop[nr][2] != 0) nr++;    // If there is one more segment..

                }

            }

        // PERIODICAL INTEREST AMOUNT for the balloon:

        if (rate_segments) 
            {


            /* When 'rate_segments' == true, and the balloon spans more then one segment in 'price_storage', the interest rate amount 
            for the balloon is computed using more than one interest rate. However, since the size of the residual/balloon does not
            change throught the loan period, the periodical interest rate amount does not either. 

            We first search for the highest interest rate segment that overlaps the resiudal. We can infer this from the length of the
            two arrays/matrixes 'price_storage' and 'price_storage_cop'. If they have the same length, this means that the balloon 
            is computed with one interest rate only, and this rate is the same as the lowest rate in 'price_storage'. If 'price_storage'
            if one segment longer, there is probably two interest rates for 'balloon' */

            var start = price_storage.length - price_storage_cop.length + 1;    // +1 guarantees at least one run-through

            var high;

            for (i=start;i>0; i--)
                {

                if (balloon > price_storage[i][1] || price_storage[i][1] == "") 
                    {

                    if (price_storage[i][2] == "") high = balloon; else high = price_storage[i][2]; // "" => unlimted

                    if (balloon > high) interest_amount_res += (high - price_storage[i][1])* price_storage[i][4]/rate_divisor;
                    else
                    interest_amount_res += (balloon - price_storage[i][1])* price_storage[i][4]/rate_divisor;
                    

                    }
                }


            }

        }


        // In order for the algoritm to be stringent, we use 'price_storage_cop' also when there is no balloon:

        else price_storage_cop = price_storage.slice(); // Slice() copies the whole array: 'price_storage_cop' is a copy of 'price_storage'




/*
¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤
//////////////////////////      3) THE NUMBER OF PERIODS IN EACH INTERVAL:          ////////////////////////////////////////
¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤

    
In order to compute the effective interest rate, we have to know the amount of every payment between the lender and the borrower and on what 
time they occur. 

This part of the program determines how many payments are made with each interest rate (most often, there is only one) and what the payment in 
that interval is.

(When there is only one interest rate, there is of course only one period -  the whole loan period - and one annuity/payment amount).

The values are stored in the array/matrix 'interval_data', which subsequently will be used during the iterations in order to compute the 
effective interest rate.

We find nominal interest rates, fees and segment limits in the function parmeter array 'price_storage'. In this section, we use an adjusted copy, 
called 'price_storage_cop'. The segment limits in 'price_storage_cop' might have been reduced by the size of an eventual residual/balloon 
payment.

Two external functions, 'intervall()' and 'intervall_separate()', computes the number of payments in each interval. They return this number in an 
array were the annuity / periodic payment is also computed.

We traverse the array 'price_storage_cop' backwords, because the principal is highest at the beginning, normally overlapping the higher segments 
of 'price_storage_cop', eventually being paid down to lower segments.

The thresholds are not passed unless we pay installments, so we are searching for the number of periods only in the segments of the loan where 
installments are paid. An interest-only period is handled later.

All annuities are composed by an interest part and and installment part. For each term, the installment is subtracted from the principal.

When the principal passes an eventual segment threshold, we should change to the next interest rate. We notice at which time this happens, and 
store this number of periods in 'interval_data'. We also store the annuity of the interval in 'interval_data'.

*/

    var interval_data = new Array();        // An array/matrix that stores intermediate values in a structured form

/*  

Each row in the array/matrix 'interval_data':

interval_data[x][0] -> payment              Net periodic payment, exclusive of fees, rounded
interval_data[x][1] -> number of terms;         The number of periodic payments it takes to pay down this segment of the loan
interval_data[x][2] -> periodic fee             Practical to have here
interval_data[x][3] -> adjusted lower segment limit     Since the number of periods must be and integer, you rarely hit the segment limit 
                                accurately. The next segments limits must be adjusted accordingly.
interval_data[x][4] -> upper segment lomit      Normally the same as 'price_storage[step][2]', but could also be adjusted
interval_data[x][5] -> remainder;           Fractions of cents we pay to little or too much each time due to rounding // OBSOLETE/ UNNECESSARY?

*/  
    

    var periods_remaining = installment_periods;    // Periodic payments left of the overall loan period
    var lowlimit;                   // Lower limit for the current loan segment
    var highlimit;                  // Upper limit for the current loan segment
    var interest_segment;               // Interest rate in the current loan segment
    var interval = 0;               // Index of the current segment in 'price_storage'
    var highest_segment = 1;            // Index of the the highest index in 'price_storage'
    var lowest_segment = 1;             // Index of the the lowest index in 'price_storage' 
    var rate_am_int_only = 0;           // Periodic interest amount in an interest-only period
    var found = false;              // Set to 'true' to interrupt the traversing of 'price_storage'
    var i = price_storage_cop.length-1;     // Index of the current segment/row in 'price_storage' 
    var segm_lowlim;                // Intermediate variable (storage of lower segment limit)
    var segm_highlim;               // Intermediate variable (storage of upper segment limit)
    var upper;                  // Intermediate variable (storage of upper segment limit)
    var step;                   // Intermediate variable (number of relevant segments in 'price_storage')
    var annuity_unrounded = 0;          // Intermediate variable
    var nextsegment;                // Intermediate variable


    while (i>=1 && found == false)
        {

        // We make room for five data for each row in the array/matrix 'interval_data[x][y]' (see above):


            interval_data[i] = new Array(5);    


        // The lower limit of the segment, 'price_storage_cop[x][y]', derived from 'price_storage[x][y]' - a parameter to the function:


            segm_lowlim = price_storage_cop[i][1];  // Current segment's lower limit 
                                

        // If segm_lowlim does not exixt in segment 1, it is interpreted as the segment starting on zero:


            if ((!segm_lowlim || segm_lowlim == "") && i == 1) segm_lowlim = 0;


        // If segm_highlim does not exist, it is interpreted as unlimited 


            if (!price_storage_cop[i][2]) segm_highlim = ""; else segm_highlim = price_storage_cop[i][2];   // Current segment's upper limit 
    

        /* Now having detected the lower and upper limit of the segment, we check if any part of the principal lays inside the interval.
        We use 'principal_ann', less an eventual residual/ballon payment, as our principal: */


            if (((principal_ann>=segm_lowlim && segm_lowlim !== "") && (principal_ann<=segm_highlim || segm_highlim == "" || segm_highlim == "Unlimited")) || interval>0) 
                {

                /* 
                
                Interpretation of the above conditions:     

                a) principal_ann>=segm_lowlim && segm_lowlim !== "":

                If the principal is greater than or equals the lower limit of the current segment, and the current segment is 
                set, this might be a segment that overlaps the whole or part of the loan.

                b) principal_ann<=segm_highlim || segm_highlim == "" || segm_highlim == "Unlimited": 

                If additionally the principal is less or equal to the upper segment limit, or the upper limit is not set 
                (signifying an unlimited loan segment), we have found a segment that encompasses the whole or part of the 
                loan.

                c) 'interval' > 0:

                If we already found a valid segment in an earlier loop, then we now that this segment is part of the loan 
                (since we transverse the array from above)

                If the interest rate is the same throughout the loan  ('rate_thresholds' == false), we don't have to check
                any more segments. We just retrive this rate from 'price_storage_cop'.
        
                This is not the case if 'rate_segments' == true. Then we must use all relevant segments in 'price_storage_cop'.

                */

                if (!rate_segments)     // Parameter of the function: If there cannot be separate, parallell rates .. 
                    {
            
                    if (!rate_thresholds)   // Parameter of the function: If the interest rate does not change ..
                        {

                        /* IF ONLY ONE INTEREST RATE..

                        In this case, there is only one interest segment - consisting of all periods (see
                        type i) in the introductory comments to this function).

                        The interest rate is the same throughout the loan  ('rate_thresholds' == false), we don't have 
                        to check any more segments. We just retrive this rate from 'price_storage_cop' in the current 
                        segment and stop the looping */

    

                            step = 1;           // Number of segments in the loan

                            lowlimit = 0;           // Low limit of the one segment

                            highlimit = principal_ann;  // High limit of the one segment
    
                            found = true;           // End looping

                            /* When there are more than one segment, the variable 'periods_remaining' will be 
                            updated for each call of the function 'interval_length'. But not here, where there
                            is only one interest rate. 

                            When the first payment, rather than the number of loan terms, are given. We compute
                            the number of loan terms here and store the value in the variable 'periods_remaining' by means 
                            of the external function 'termnum_annu()':*/

                            
                        }
                    else
                        {

                        /* IF ONLY ONE INTEREST RATE AT THE TIME..

                        The interest rate for the whole loan might change when certain thresholds are overstepped (see
                        type ii) in the introductory comments to this function).*/


                            step = i; // All relevant segments will be used during the computation



                        /* We store the number of relevant segments. There are always at least one. Since we are counting
                        backwords, from the upper segment,  'highest_segment' - that was initially set to '1' - is set 
                        only once:  */


                            if (highest_segment == 1) highest_segment = i;
            
                            lowlimit = segm_lowlim;     // For the current segment

                            if (segm_highlim == "" || principal_ann<=segm_highlim) highlimit = principal_ann;



                        /* Since the number of periods in each intervall must be an integer, we will hardly ever
                        find a number of periods that make the principal being paid down to precisely the lower 
                        segment limit. Normally, our installments will have paid the principal down below the limit by
                        some cents. This remaining principal must be set as the new upper limit of the next segment.

                        We must check whether such a limit was set in the former segment. Since we are looping 
                        backwords, the former segment is the segment 'step+1'.

                        If such a new limit was set, it will be the new high limit of the current segment.

                        */
                    

                            else if ((eval(step)+eval(1)) < interval_data.length && interval_data[step+1][3] > 0) 
                            highlimit = (eval(interval_data[step+1][3]));
                            else highlimit = segm_highlim;

                
                        }


                    /*  ..IN BOTH CASES:

                    In element 4 in 'price_storage_cop' lies the interest rate of the current segment:*/


                        interest_segment = price_storage_cop[i][4];


                    /* Interest amount from an eventual balloon:

                    In order for the external function 'intervallength()' to be able to round the periodic payments 
                    correctly, we must know the interest amount for the balloon. When 'rate_segments' == false, as 
                    in this part of the program, the interest amount of the balloon is computed with the same 
                    interest rate at the rest of the loan:   */


                        interest_amount_res = balloon * interest_segment/ rate_divisor;


                    /* The function 'intervallength' computes how many periods it takes to pay down the current segment. 
                    
                    // NEW IN VERSION 1.1.:

                    If the value for the number of periods - 'numberofperiods' - is not given, but 'firstpayment' is given
                    instead, we must first compute the number of periods - here expected in the parameter 'periods_remaining'.
                    For this purpose, we use the function 'termnum_annu()': */


                        if (firstpayment != "") // If the user has entered the annuity rather than the number of payments
                                {

                                /* Only the net part of the payment - when fees are deducted - are used by the bank
                                to service the loan. We thus have to deduct the fixed fee and the eventual percentage fee. 
                                We also deduct the interest of an eventual ballon: */

                                var netpayment = (firstpayment * 12/capitalization_freq) - price_storage_cop[i][3] - highlimit*fee_period_perc/100 - interest_amount_res;

                                /* Here, 'periods_remaining' is not given, so we must compute it: */

                                periods_remaining = termnum_annu(highlimit ,netpayment ,price_storage_cop[i][4]/rate_divisor , advance);

                                
                                }

                    // END - NEW IN VERSION 1.1.
                    /* The function 'intervallength' computes how many periods it takes to pay down the current segment. 
                    It also computes other useful numbers and return them as a row in the array/matrix 'interval_data' 
                    (see the definition of the elements in 'interval_data' further above): */


                        interval_data[step] = intervallength(highlimit,interest_segment,lowlimit,periods_remaining,round_direction,round_presision,rate_divisor,interest_amount_res,advance); 

                        if (interval_data[step] == -6) return -6;   // Error: Failing convergence 

                            
                    }

                else 

                    {

                    /* ALL SEGMENTS WITH SEPARATE, PARALLELL INTEREST RATES..


                    'rate_segments' == 'true' means the interest rate for the whole loan might change when certain thresholds 
                    are overstepped (see type iii) in the introductory comments to this function). */

                        step = i;

                    /* In order for the function 'intervallength_separate()' to be able to compute the whole payment of the 
                    interval - the sum of the payments in the separate, parallell segments - it must have information of all
                    segments. 

                    This information resides in the function parameter 'price_storage' and the derived version we use here - 
                    'price_storage_cop'. But a subtle problem arises: Since the number of periods in each intervall must be 
                    an integer, we will hardly ever find a number of periods that make the principal being paid down to 
                    precisely the lower segment limit. Normally, our installments will have paid the principal down below 
                    the limit by some cents. This remaining principal must be set as the new upper limit of the next 
                    segment.

                    We must check whether such a limit was set in the former segment. Since we are looping  backwords, the 
                    former segment is the segment 'step+1'.                 
                

                    We store the number of relevants segments. Since 'highest_segment' is initiated to '1', it will be set 
                    only once: */


                        if (highest_segment == 1) highest_segment = i;

            
                    /* If the upper limt is not set, eller the principal is smaller than the maximum limit, the highest 
                    limit equals the principal: */


                        if (segm_highlim == "" || principal_ann<=segm_highlim) price_storage_cop[step][2] = principal_ann;

                
                    /* In 'interval_data[x][3]' for the former segment lies the real, functional lower limit of that segment. We 
                    check whether it exists. If it does, it is also the upper limit for the current segment:  */


                        nextsegment = eval(step)+eval(1);

                        if (nextsegment < interval_data.length && interval_data[nextsegment][3] && interval_data[nextsegment][3] > 0 && interval_data[nextsegment][3] != "Infinity") 
                        price_storage_cop[step][2] = interval_data[nextsegment][3];

                    /* Now, we can invoke the function 'intervallength_separate()' that returns a fully computed row in 
                    the matrix 'interval_data': */
                
                        interval_data[step] = intervallength_separate(price_storage_cop,step,periods_remaining,round_direction,round_presision,rate_divisor,interest_amount_res,advance);

                        if (interval_data[step] == -6) return -6;   // Error: Failing convergence 

                
                    if (installment_grace_periods > 0)

                        {
                        /* No installment is being paid in an interest-only period. We just have to sum up the interest
                        amounts of all parallell segments overlapping the whole loan.

                        An empty, upper limit for a segment is intepreted as "unlimited":
                        */


                            if (price_storage_cop[step][2] > principal_ann || price_storage_cop[step][2] == "" || price_storage_cop[step][2] == 0) upper = principal_ann; else upper = price_storage_cop[step][2];

                    
                        /* 'rate_am_int_only' - the periodic interest amount during an interest only-period will be used
                        in the section for 'installment_grace_periods' below: */
                    
                            rate_am_int_only += (upper - price_storage_cop[step][1]) * price_storage_cop[step][4]/rate_divisor; 

                    
                        }


            
                    }               

                if (balloon > 0)

                    {

                    /*  If this loan has a residual/ballon, the periodic payment we have computed is too low. It does
                    not contain the interest amount for the part of the loan where only interest is paid.

                    We have to add this amount here. 'interval_data[step][0]' contains the rounded periodic payment.

                    Since it in somE cases impacts the rounding, we add the remainder. We find the remainder in  
                    'interval_data[step][5]'.

                    But if the remainer is to be ignored - 'remainder_handling == 1', we simply round the remainer as
                    if is. */


                        if (remainder_handling != 0) // If the remainder after paying off the loan is not to be ignored
                            {
                

                            annuity_unrounded = interval_data[step][0] + interest_amount_res + interval_data[step][5];

                
                        /* As we now have added the interest amount for the balloon, we round again and subsitute the 
                        old remainder with the new: */

                 
                            interval_data[step][0] = roundoff(annuity_unrounded, round_direction, round_presision);


                        /* The remainder when rounding the periodical payment was computed either in the function 
                        'intervallength()' or the function 'intervallength_separate()' and is placed in 
                        'interval_data[step][5]'

                        But when we computed a new periodical periodical payment, we rounded again and thus get a new
                        remainder. */


                            interval_data[step][5] = annuity_unrounded - interval_data[step][0]; 

                            }

                        else interval_data[step][0] = roundoff(interval_data[step][0] + interest_amount_res, round_direction, round_presision);

        
                    }

            
            
                /* In order to have all data  relevant for the interest rate computation in one place, we also add the
                periodical fee to 'interval_data': */


                    interval_data[step][2]  = price_storage_cop[step][3];


                /* Some loans might have a periodical fee that is computed as a percentage of the credit limit instead of or
                in addition to the fixed fee. We make the presumption that the loan is drawn fully to the credit limit at
                the beginning of the loan period, so that the fee is always computed from the intial principal (the initial
                laon plus fees: */


                    if (fee_period_perc) interval_data[step][2] += principal*fee_period_perc/100;

                
                
                    periods_remaining -= interval_data[step][1];

                    interval++;
            

                }

            i--;    // We loop the array 'price_storage_cop' backwards
        }


// if (price_storage[1][4] == 4 && price_storage.length>2) alert(interval_data);    

// STOP if no interval is detected, usually because the loan amount is too big or too small:

if (interval == 0) return -5;

/* 
¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤
//////////////////////////      4) AN EVENTUAL INTEREST-ONLY PERIOD:        ////////////////////////////////////////////////////////
¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤

// NEW IN VERSION 1.1.:
ASSYMETRIC MODES:

when there is an initial interest-only period, the symmetry brakes between period mode and payment mode. When there is 'firstpayment' provided 
by the user (period mode), this payment is interpreted as having to cover the highest payment during the whole payment period. When there is an 
intial interest free period, this will NOT be the first payment, but one of the payments after he starts paying off the loan. In payment mode, 
however, we return the first payment.

// END - NEW IN VERSION 1.1.


*/

var unrounded;

if (installment_grace_periods)
    {


    /* In the array/matrix 'interval_data[x][y]', we now have stored all the information we need in order to compute the effective interest 
    rate, beginning in row one (x = 1). Corresponding information about an interest-only period will be put in a new last row of the matrix.
        
    */


        highest_segment++;  // We get a new step in the staircase, and increment the counter.


    /* The periodic interest amount paid during the interest-only periods, 'rate_am_int_only', was only computed for loans with separate, 
    parallell interest rates: */


        if (rate_segments) unrounded = rate_am_int_only + interest_amount_res;
    

     // Otherwise, the periodic interest amount is simply the interest rate in the highest relevant segment, 'interest_segment', multiplied with the principal:


        else unrounded = principal * interest_segment/rate_divisor;


    // We create the new matrix row and fill it with data:


        interval_data[highest_segment] = new Array(5);


        interval_data[highest_segment][0] = roundoff(unrounded, round_direction, round_presision);


    // The number of terms/periods we pay this periodic payment:


        interval_data[highest_segment][1] = installment_grace_periods;


    // The size of the principal at the end of the interval. Here, it's the same as at the beginning, since no installments are paid:


        interval_data[highest_segment][3] = principal_ann; 


    // The interest-only period can only run from the beginning of the loan period. Then, the principal is yet not paid down:


        interval_data[highest_segment][4] = principal_ann; 

        
    // Remainder when rounding the periodic payment: 


        interval_data[highest_segment][5] = unrounded - interval_data[highest_segment][0];


    // The periodic fee is set to the same amount as for the first ordinary annuity period:


        interval_data[highest_segment][2] = price_storage[highest_segment-1][3];


    // There could also be a periodic fee computed as a percentage of the principal:

        
        if (fee_percentage) interval_data[highest_segment][2] += principal*fee_percentage/100;

    }





/*
¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤
//////////////////////////      5) GLOBAL REMAINDER     ////////////////////////////////////////////////////////////////////////
¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤





COMPUTING THE GLOBAL REMAINDER

When computing an annuity, we typically get numbers as 234.938267484958. This is not payable in a bank. 234.94 is, but these slightly too big
annuity will make us overshoot the target payment at the end of the loan period (we pay a little too much).

This amount is the "global residue". It is either ignored or compensated. It it is compensated, this is normally done with the last payment in 
the loan period. Freeloan also supports it being compensated for in the first payment.

*/


    var disko,residue,gross_last;   


//round_presision, 0, 'false' or omitted: Payment rounded to nearest 1/100 1: Rounded to nearest integer


    if (round_presision == 1) disko = 1; else disko = 100;  // 'disko' is a divisor used when rounding


/* 'interval_data[1][3]' contains the remaining principal at the end of each loan interval. When the last segment is paid, the remaining principal
will be the global residue for the whole loan. The last segment to be paid is segment 1. (Of course, normally there is only one segment).

We will now compute the non-rounded, last payment in the loan, included remainder and balloon. We call it 'gross_last'.

'gross_last' is the sum of:


'interval_data[1][0]'   -> the rounded annuity      

'interval_data[1][5]'   -> the remainder after rounding the annuity, stored in 
 
'interval_data[1][3]'   -> the non-raounded remainder of the principal after all periodic paymenst are made

'balloon'       -> an eventuelt residual/ballon payment (stored in the variable 'balloon')
    
'interval_data[i][2]'   -> the periodic fee 


When there is more than one segment, we pay the loan "backwords" through the array 'interval_data'. The last interval's values are always in 
row 1. Hence, we use 'interval_data[1][x]' to compute the precise global residue:  */


    gross_last = interval_data[1][0]+interval_data[1][5]+interval_data[1][3]+eval(balloon)+interval_data[1][2];


/* The residue to be paid/compensated for with the last payment is the last payment - 'gross_last' - minus the rounded, ordinary payment: */


    if (remainder_handling == 0 || !remainder_handling || remainder_handling == "") residue = Math.round(gross_last*disko)/disko-(interval_data[1][0]+interval_data[1][2]);


// ..if the residue is just ignored:


    else residue = Math.round(balloon*disko)/disko  // The planned residual/balloon is never ignored and always payed with the last payment.



/*
¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤
//////////////////////////      6) EFFECTIVE INTEREST RATE:     ////////////////////////////////////////////////////////////////
¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤

As we now have an array/matrix containing all amounts due and the number of periods they should be paid, we can compute the effective interest
rate.

We apply the annuity formula:


1) ANNUITY-IMMEDIATE

(When 'advance == true')


*********************************************************************************
|                                       |
|   FORMULA FOR ANNUITY-IMMEDIATE:                      |
|                                       |
|                                       |
|   annuity = loan * (1 - k) / (k - Math.pow(k,termnumber+1));      |
|                                       |
|                                       |
|   where                                   |
|                                       |
|                                       |
|   k = 1/(1+rate);                             |
|                                       |
|                                       |
*********************************************************************************

We want to compute 'rate'.

We use other variable names:

payment = principal * (1 - k) / (k - Math.pow(k,calculation_periods+1));    

We rearrange it with respect to 'principal':

payment/principal =  (1 - k) / (k - Math.pow(k,calculation_periods+1));

=> principal * (1-k) = payment * (k - Math.pow(k,calculation_periods+1));

=> principal = payment * (k - Math.pow(k,calculation_periods+1))/ (1-k);

We want the right hand expression to be a present value equal to 'principal'. For computation purposes, we thus call the principal 'PV':

PV = payment * (k - Math.pow(k,calculation_periods+1))/ (1-k);

We formerly computed the values for the array 'interval_data'. This array is two-dimentional. In each row (representing a rate segement) the
three first elements contain:

interval_data[i][0] -> annuity
interval_data[i][1] -> the number of payments in this interval
interval_data[i][2] -> periodic fee in the segment

For each interval/step we shall now compute the present value of the stream of payments from the beginning to the end of the interval.

We do that by subtracting the present value of one stream of payments from another:


1) A strem of payments with the current periodical amount running from the first payment in the loan to the last payment in the interval:

payment * (k - Math.pow(k,interval_end+1))/ (1-k)

2) Minus a strem of payments with the same amount running from the first payment in the loan to the first payment in the interval:

payment * (k - Math.pow(k,interval_start+1))/ (1-k)


The present value of the payment stream from the beginning to the end of the interval transpires by subtracting the second expression from the first:

PV = payment * (k - Math.pow(k,interval_end+1))/ (1-k) - payment * (k - Math.pow(k,interval_start+1))/ (1-k)

We simplify:

=> PV = (payment * k - payment * Math.pow(k,interval_end+1) - payment * k + payment * Math.pow(k,interval_start+1))/ 1-k

The terms 'payment * k' falls against each other, and we get:

=> (payment * Math.pow(k,interval_start+1) - payment * Math.pow(k,interval_end+1)) / 1-k

We can isolate 'payment / (1 - k)':

PV = (payment/(1-k)) * (Math.pow(k,interval_start+1) - Math.pow(k,interval_end+1));

'k' (the discount factor) is the unknown entity in our expression. The other variables are known.



 
2) ANNUITY-DUE

(When 'advance == false')

*********************************************************************************
|                                       |
|   FORMULA FOR ANNUITY-DUE:                        |
|                                       |
|                                       |
|   annuity = loan * (1 - k) / (1 - Math.pow(k,termnumber));        |
|                                       |
|                                       |
|   where                                   |
|                                       |
|                                       |
|   k = 1/(1+rate);                             |
|                                       |
|                                       |
*********************************************************************************


We reason the same way as for annuity-immediate, but use the annuity-due formula

PV = payment * (1 - Math.pow(k,termnumber))/(1 - k);

So that our present value becomes:

PV = payment * (1 - Math.pow(k,interval_end))/ (1-k) - payment * (1 - Math.pow(k,interval_start))/ (1-k)

And the algebra:

PV = payment/(1-k) - payment * Math.pow(k,interval_end)/(1-k) - payment/(1-k) + payment * Math.pow(k,interval_start)/(1-k)

The first and third term falls, leaving:

PV = payment * Math.pow(k,interval_start)/(1-k) - payment * Math.pow(k,interval_end)/(1-k)

Common factor payment/(1-k) put ouside:

PV = payment/(1-k) * (Math.pow(k,interval_start) -  Math.pow(k,interval_end))




************************************************************************************************************************************************



NEWTON'S METHOD - DIFFERENTIATION

No formula gives us the effective interest rate directly. We find it by trying a likely value for 'k', adjusting it until we get the interest
rate with the accuracy we want. Newton's method shortenes this try and fail process. It postulates that our 'k' will be found close to where the
tangent to the curve in the present PV/k point crosses the k-axes: 

http://en.wikipedia.org/wiki/Newton%27s_method

The graph is in the PV/k space. A value of 'k' will give a value of 'PV': PV = f(k).

The steepness of the tangent line is given by the differentiated function with respect to 'k':

PV = (payment/(1-k)) * (Math.pow(k,interval_start+1) - Math.pow(k,interval_end+1));

For easier differentiation, we handle the two expressions on each side of the multiplication sign separately. We call them 'A' and 'B';

PV = A*B; where

A = payment/(1-k);

B = Math.pow(k,interval_start+1) - Math.pow(k,interval_end+1);

One can find the differentiation rules on wikipedia: http://en.wikipedia.org/wiki/Differentiation_rules

PV' = A'*B + A*B'   

We fist differietiate 'A' separately according to the Quotient rule:

A' = (payment' * (1-k) - payment* (1-k)') / (1-k)^2

The differntiated of the constant 'payment' is 0. The differentiated of the variable 'k' er 1:

=> A' = - payment* (1-k)' / (1-k)^2

=> A' = payment / Math.pow(1-k,2)

Then we differentiate 'B' according to the Power rule (y = x^n => y' = n*x^(n-1)):

B = Math.pow(k,interval_start+1) - Math.pow(k,interval_end+1);

B' = (interval_start+1)*Math.pow(k,interval_start) - (interval_end+1) * Math.pow(k,interval_end)

We then assemble the whole differentiated PV according to the Product rule:

PV' = (payment / Math.pow(1-k,2)) * (Math.pow(k,interval_start+1) - Math.pow(k,interval_end+1)) + (payment/(1-k))*((interval_start+1)*Math.pow(k,interval_start) - (interval_end+1) * Math.pow(k,interval_end));

As there is no notation for the differentiated in the programming language, we rename the differentiated PV' 'PV_dif':

PV_dif = PV' 



ANNUITY-DUE


(When 'advance == false')

We reason the same way:

PV = payment/(1-k) * (Math.pow(k,interval_start) -  Math.pow(k,intervallslutt))

A = payment/(1-k);

B = Math.pow(k,interval_start) -  Math.pow(k,interval_end);

One can find the differentiation rules on wikipedia: http://en.wikipedia.org/wiki/Differentiation_rules

PV' = A'*B + A*B'   

We fist differietiate 'A' separately according to the Quotient rule:

A' = (payment' * (1-k) - payment* (1-k)') / (1-k)^2

Den dervierte av konstanten 'payment' er 0. Den deriverte av variablen 'k' er 1:

=> A' = - payment* (1-k)' / (1-k)^2

=> A' = - payment / Math.pow(1-k,2)

Then we differentiate 'B' according to the Power rule:

B = Math.pow(k,interval_start) - Math.pow(k,interval_end);

B' = interval_start * Math.pow(k,interval_start-1) - interval_end * Math.pow(k,interval_end-1)

We then assemble the whole differentiated PV' according to the Product rule:

PV' = (payment / Math.pow(1-k,2)) * (Math.pow(k,interval_start) - Math.pow(k,interval_end)) + (payment/(1-k))*(interval_start*Math.pow(k,interval_start-1) - interval_end * Math.pow(k,interval_end-1));

As there is no notation for the differentiated in the programming language, we rename the differentiated PV' 'PV_dif':

PV_dif = PV' 

************************************************************************************************************************************************



ITERATIONS:


We have two, pretty much identical, alternative while-loops for computing annuity-due and annuity-immediate, respectively. Instead, we could have
performed frequent if-test inside the loops, but this would probably have impaired performance more.

When the function is called, at least one nominal interest rate will be among the parameters - the rate in the lowest segment. We skal use this 
rate as our first guess as to what the effective interest rate might be.

THe function does not use interest rate directly, only via the discount factor 'k' */


    var k = 1 / (1+price_storage[1][4]/rate_divisor);   // First suggestion: The array 'price_storage' is a parameter to the function

    var rounds = 0; // Counts the number of iterations
    var PV = 0; // The present value
    var PV_dif = 0; // the differiented of the present value
    var payment;    // The peridoical payment in the annuity loan, included fees
    var y = 1;  // 'y' is the function value that we want to make close to '0'. Givaen av value so we can enter the 'while'-loop.

    var interval_start; // The number of payments from the start of the loan period until the interval starts
    var interval_end;   // The number of payments from the start of the loan period until the interval ends


    if (advance)    // Annuities paid at the beginning of each period - annuity-due

        {

        while (Math.abs(y) > 0.000001 && rounds<100)    // Here, we set the accuracy we want.
            {

            PV = 0;     // The present value of the payments
            PV_dif = 0; // The differentiated of the present value
        
            interval_start = 0;
            interval_end = 0;

            
            /* Now, we compute the present value 'PV' and the corresponding differetiated 'PV_dif' for each interval of the loan, given the 
            current guess for the discount factor 'k.

            In the case where the loan runse with different interest rates in succeeding intervals, we sum the present value for each. We 
            also sum their differentiated values. */

            for (i=highest_segment;i>0;i--) 
                {

                /* In order to compute the effective interest rate, we must compare all we pay with all we receive. Hence, we must 
                include eventual fees in the periodic payments. The fee is in 'interval_data[i][2]': */

                payment = eval(interval_data[i][0])+eval(interval_data[i][2]);

                interval_start = interval_end;  // The end of the former interval is the start of this

                interval_end += interval_data[i][1];    // The upper limit of this interval
                            
                PV += payment/(1-k) * (Math.pow(k,interval_start) -  Math.pow(k,interval_end));

                /* The sum of the differentiated of two functions is the sum of the difrentiated. Hence, we simply sum the 
                differentiated in each interval */
            
                PV_dif += (payment / Math.pow(1-k,2)) * (Math.pow(k,interval_start) - Math.pow(k,interval_end)) + (payment/(1-k)) * (interval_start * Math.pow(k,interval_start-1) - interval_end * Math.pow(k,interval_end-1));

                    
                }
        
            /* One payment - the residue - is so far missing. We add the present value of the residue to the present value of
            the other payments. If it is paid in the last period, it must be discounted to find the present value.
            The residue is already rounded. In annuity-due (annuities in advance) the last payment is in period 'calculation_periods-1': */


                PV += residue*Math.pow(k,calculation_periods-1); 


            /* We also want to add the differentiated of the residue to the differiented of the other payments. 

            The residue is a function of 'k', and we use the Power rule (http://en.wikipedia.org/wiki/Power_rule): 

            y = x^n => y' = n*x^(n-1): 

            PV_res = residue*Math.pow(k,calculation_periods-1) => PV_res_dif = residue*(calculation_periods-1)*Math.pow(k, calculation_periods-2);

            */


        
                PV_dif += residue * (calculation_periods -1) * Math.pow(k, calculation_periods-2);  
    
                y = PV-received;                // Searching for a 'k' making y = 0. Since 'received' is a constant y' = PV'
        
                delta = -y/PV_dif;              // The increase in 'k' necessary at the tangent's intersection with the PV-axis

                if (eval(k)+eval(delta) != 1) k += delta;   // We increase/decrease 'k' (the annuity function crashes at k=1)

                rounds++;
        
        
            }

        }
    else        // Annuities paid at the end of each period - annuity-immediate - "normal" annuities.
        {

        while (Math.abs(y) > 0.000001 && rounds<100)    // Here, we set the accuracy we are looking at.
            {

            PV = 0;     // The present value of the payments
            PV_dif = 0; // The differentiated of the present value
        
            interval_start = 0;
            interval_end = 0;

            
            /* Now, we compute the present value 'PV' and the corresponding differetiated 'PV_dif' for each interval of the loan, given the 
            current guess for the discount factor 'k.

            In the case where the loan runse with different interest rates in succeeding intervals, we sum the present value for each. We 
            also sum their differentiated values. */

            for (i=highest_segment;i>0;i--) 
                {

                /* In order to compute the effective interes rate, we must compare all we pay with all we receive. Hence, we must 
                include eventual fees in the periodic payments. The fee is in 'interval_data[i][2]': */

                payment = eval(interval_data[i][0])+eval(interval_data[i][2]);

                interval_start = interval_end;  // The end of the former interval is the start og this

                interval_end += interval_data[i][1];    // The upper limit of this interval
                            
                PV += payment/(1-k) * (Math.pow(k,eval(interval_start)+eval(1)) - Math.pow(k,eval(interval_end)+eval(1)));

                /* The sum of the differentiated of two functions is the sum of the difrentiated. Hence, we simply sum the 
                differentiated in each interval */
            
                PV_dif += (payment/ Math.pow(1-k,2)) * (Math.pow(k,eval(interval_start)+eval(1)) - Math.pow(k,eval(interval_end)+eval(1))) + (payment/(1-k))*((eval(interval_start)+eval(1))*Math.pow(k,interval_start) - (eval(interval_end)+eval(1)) * Math.pow(k,interval_end));
            
                    
                }
        
            /* One payment - the residue - is so far missing. We add the present value of the residue to the present value of
            the other paymen. If it is paid in the last period, it must be discounted to find the present value.

            The residue was rounded when we computed it earlier: */


                PV += residue*Math.pow(k,calculation_periods); 



            /* We also want to add the differentiated of the residue to the differiented of the other payments. 

            The residue is a function of 'k', and we use the Power rule (http://en.wikipedia.org/wiki/Power_rule): 

            y = x^n => y' = n*x^(n-1): 

            PV_res = residue*Math.pow(k,calculation_periods) => PV_res_dif = residue*calculation_periods*Math.pow(k, calculation_periods-1);

            */


        
                PV_dif += residue*calculation_periods*Math.pow(k, calculation_periods-1);   
    
                y = PV-received;                // Searching for a 'k' making y = 0. Since 'received' is a constant y' = PV'
        
                delta = -y/PV_dif;              // The increase in 'k' necessary at the tangent's intersection with the PV-axis

                if (eval(k)+eval(delta) != 1) k += delta;   // We increase/decrease 'k' (the annuity function crashes at k=1)

                rounds++;
        
        
            }

        }

/* 'k' is a discouting factor that was defined as k = 1/(1+e) where 'e' is the periodic, effective interest rate as decimal fraction. (1+e) is
the growth rate for each period. Hence, the growth rate for a year is (1+e)^12 (if there are 12 capitalizations per year). The effective, 
annual interest rate in decimal fraction, thus, is ((1+e)^12)-1. In percentage: er = (((1+e)^12)-1)*100. 
Since k = 1/(1+e)  => (1+e) = 1/k, we substiute and get er = ((1/k)^12-1)*100: */


    er = (Math.pow(1/k,capitalization_freq) - 1)*100; // 'er' is the effective annual interest rate - the principal result of the function


/* 


¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤
//////////////////////////      7)  RESULT REPORTING            ////////////////////////////////////////////////////////////////
¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤


The function primarily computes the effective interest rate. But as a bi-product, several other avalues were computed along the way. These could
come handy during the result presentation - for instance the length of the intervals, the fees, the balloon.

It is natural to return these values as a multidimentional array.

The array 'res' had these values:

res[0] -> Effective annual interest rate
res[1] -> residue: What is left of the loan in the last term due to rounding
res[2] -> The array 'interval_data', that contains:
    
    interval_data[x][0] -> payment              Net periodic payment, exclusive of fees, rounded
    interval_data[x][1] -> number of terms;         The number of periodic payments it takes to pay down this segment of the loan
    interval_data[x][2] -> periodic fee             Practical to have here
    interval_data[x][3] -> adjusted lower segment limit     Since the number of periods must be and integer, you rarely hit the segment limit 
                                accurately. The next segments limits must be adjusted accordingly.
    interval_data[x][4] -> upper segment limit      Normally the same as 'price_storage[step][2]', but could also be adjusted
    interval_data[x][5] -> remainder;           Fractions of cents we pay to little or too much each time due to rounding

*/

    res = new Array(3);
    res[0] = er;
    res[1] = residue+" / "+rounds;  
    res[2] = interval_data; 

    /* Normally, we pay more the last periods when there is an inital interest only-period. But when the borrower has specified that he is able
    to pay only a maximum sum - 'firstpayment' - per month, we have to prolong the payment period instead: */
    
    res[3] = 0; // res[3] contains the number of payback periods.

// NEW IN VERSION 1.1.:
    if (rate_thresholds && firstpayment > 0)    // Where there are several intervals, we sum them up
        {

        for (i=1;i<interval_data.length;i++) if (interval_data[i][1]) res[3] += Number(interval_data[i][1]);
        res[3] += installment_grace_periods;

        }
    else res[3] = interval_data[1][1]+installment_grace_periods;    // The payback period in number of payments
// END - NEW IN VERSION 1.1.

    return res;


/* END function annuityLoan() */}
































// NEW IN VERSION 1.1.: (The whole function termnum_annu() is new in 1.1.)

function termnum_annu(loan ,annuity ,rate ,due)
{
/*
WHAT IT DOES:

The function returns the number of periods it will take to pay down 'loan' to zero given the periodic payment 'annuity' and the 
periodic interest rate 'rate'. Either when annuities are paid in advance ('due' = true) or by ordinary annuities, paid in arrears.

PARAMETERS:

loan        ->  The size of the gross loan, included orgination fees.
annuity     ->  The periodic (often monthly) payment
rate        ->  Nominal, periodic interest rate
due     ->  TRUE if the annuities are paid in advance (annuity due)


DERIVATION: 

1) Annuity immediate:

For ordinary annuities (annuities in arrears / annuity immediate) the formula is

*********************************************************************************
|                                       |
|   FORMULA FOR ANNUITY-IMMEDIATE:                      |
|                                       |
|                                       |
|   annuity = loan * (1 - k) / (k - Math.pow(k,termnumber+1));      |
|                                       |
|                                       |
|   where                                   |
|                                       |
|                                       |
|   k = 1/(1+rate);                             |
|                                       |
|                                       |
*********************************************************************************

'rate' being the periodical interest rate in decimal form.

(k - Math.pow(k,termnumber+1)) * annuity = loan * (1 - k) 

k - Math.pow(k,termnumber+1)  = loan * (1 - k) / annuity

Math.pow(k,termnumber+1)  = k - (loan * (1 - k) / annuity) 

C = k - (loan * (1 - k) / annuity) 

Math.pow(k,termnumber+1)  = C

The logarithm rule for exponential functions:  log a^x = x * log a

log k *(termnumber+1) = log C

termnumber+1 = log C / log k

termnumber = log C / log k - 1


2) Annuity due:

For annuities in advance / annuity due, the formula is:

*********************************************************************************
|                                       |
|   FORMULA FOR ANNUITY-DUE:                        |
|                                       |
|                                       |
|   annuity = loan * (1 - k) / (1 - Math.pow(k,termnumber));        |
|                                       |
|                                       |
|   where                                   |
|                                       |
|                                       |
|   k = 1/(1+rate);                             |
|                                       |
|                                       |
*********************************************************************************


annuity = loan * (1 - k) / (1 - Math.pow(k,termnumber));

where k = 1 / (1 + r), 'r' being the periodical interest rate in decimal form.

(1 - Math.pow(k,termnumber)) * annuity = loan * (1 - k) 

1 - Math.pow(k,termnumber)  = loan * (1 - k) / annuity

Math.pow(k,termnumber)  = 1 - (loan * (1 - k) / annuity) 

C = 1 - (loan * (1 - k) / annuity) 

Math.pow(k,termnumber)  = C

The logarithm rule for exponential functions:  log a^x = x * log a

log k * termnumber = log C

termnumber = log C / log k

DECIMALS: Per definition, period numbers must be integers. This rounding must happen outside this
function, as it returns a decimal number.

*/

var k = 1 / (1 + rate);

if (due) 
    {
    var C = 1 - (loan * (1 - k) / annuity);
    return Math.log(C) / Math.log(k);
    }
else
    {
    var C = k - (loan * (1 - k) / annuity);
    return Math.log(C) / Math.log(k) - 1;
    }


/* END termnum_annu() */}




// END - NEW IN VERSION 1.1.
























function intervallength(upperlimit,rate,lowerlimit,periods,round_direction,round_presision,rate_divisor,interest_amount_res,advance)
{
/*
WHAT THE FUNCTION DOES:

It computes how many periods it takes to pay the segment's principal 'upperlimit' down to the amount 'lowerlimit' at the given interest
rate and the given number of periods ('periods') that are left of the loan period.

As its result, the function returns an array with five elements:

answer[0] = periodic peyment;   Rounded according to the rules given in the paremeters
answer[1] = number of periods;  Number of periods it takes to pay 
answer[2] = "";         (reserved for the fee - will be inserted by the calling function)
answer[3] = adjusted lower limit;   As the number of periods must be an integer, one normally passes the original loan limit
answer[4] = upperlimit;     Same as the paramter
answer[5] = rest;       Some cents / fractions of cents that are left of the periodic payment after rounding

The number of periods cannot be a decimal number. The answer is thus rounded up to the nearest integer, because we want to make sure that
the principal in the interval is payed down. (When there is subsequent intervals, the interest rate does not change before the principal
limit is surpassed).

When the number of periods are rounded up, we don't "hit" the principal limit accurately. Normally, the loan will be payed further down - the 
remaining principal is lower than the limit. This remaining principal is computed and returned in 'answer[3]'.

When we compute the number of periods, we don't include periodical fees, because these fees don't affect the remaining principal in the 
bank's books.

The peridical payment is rounded before the computations begin.


PARAMETERS

'upperlimit'        The size of the principal in this segment.
'rate'          Nominal, annual interest rate. RATE CANNOT BE ZERO (!= 0)
'lowerlimit'        Remaining principal after the interval is over.
'periods'   The remaing number of periodical payments for the whole loan when the function is called. CANNOT BE ZERO (!= 0)
'round_direction,   0, 'false' or omitted: Annuities are rounded after normal rules  1: Rounded up 2. Rounded down
'round_presision,   0, 'false' or omitted: Payment rounded to nearest 1/100 1: Rounded to nearest integer
'rate_divisor'      Factor the nominell annual rate in prosent is divided by to obtain the rate in decimal fraction
'interest_amount_res'   The interest from an eventual residual/balloon added to eache period payment.
'advance'       Bolean. If 'false', we use normal annuities (annuity-immediate). Otherwise annuities in advance (annuity-due).



DERIVATION OF FORMULAS

a) ANNUITY-IMMEDIATE

Consider a loan of 2.5 millions, where you pay 3.95% as long as the remaining principal is greater than 2 millions. You pay 4.05% when 
the loan is between 1 million and 2 millions. You pay 4.15% if the loan is paid off below 1 million. The example loan runs for 20 years 
with monthly payments, 240 payments in all:

 
We can easily compute the first annuity, using the annuity formula:


*********************************************************************************
|                                       |
|   FORMULA FOR ANNUITY-IMMEDIATE:                      |
|                                       |
|                                       |
|   annuity = loan * (1 - k) / (k - Math.pow(k,termnumber+1));      |
|                                       |
|                                       |
|   where                                   |
|                                       |
|                                       |
|   k = 1/(1+rate);                             |
|                                       |
|                                       |
*********************************************************************************

It will be 15,083.72

At some point, the first threshold 2,000,000 will be passed, and the rate changes. But how many periods will this take?

We know that if we pay 15.083.72 per month in 240 months, we will have paid the 2,5 million. The present value over 240
terms is 2,5 millions:


    PV(240) = 2,5 millons


After an unknown number of periods – x –, we will pass the 2 million threshold. Then, the present value of the remaining loan will be 
2 millions.


    PV(x) = 2 millons

    PV(240) - PV(x) = 500,000


We rearrange the annuity formula with respect to the loan:

capital = annuity * (k – k^(termnum+1)) /(1 - k) 


2,000,000 = annuity * (k – k^(x+1)) /(1 - k)

We call 2,000,000 ‘PV’ and the annuity ‘a’:

    PV = a * (k – k^(x+1)) /(1 - k)
=>  (PV * (1 – k)/a )= (k – k^(x+1)) 
=>  (PV * (1 – k)/a) –k  = – k^(x+1) 
=>  (PV * (1 – k)/a) –k  = – k^(x+1) 

We multiply by -1:

    k – (PV * (1 – k)/a)  =  k^(1+x)

The whole left side consists of constants. We can set

    II  C = k – (PV * (1 – k)/a)
    I+II    C = k^(1+x)

Taking the logarithm of both sides:

    log(C) = (1 + x) * log (k) 
=>  log(C) = log (k)+ (x * log (k))
=>  (log(C) - log (k))/log(k) = x

*********************************************************************************
|                                       |
|   TERM NUMBER FORMULA FOR ANNUITY-IMMEDIATE               |
|                                       |
|                                       |
|   terms = (log(C)- log (k))/log(k)                    |
|                                       |
|                                       |
|   where:                                  |
|                                       |
|                                       |
|   k = 1/(1+rate);                             |
|                                       |
|   C = k – (PV * (1 – k)/a)                        |
|                                       |
|   a = annuity                             |
|                                       |
|   PV = present value (capital/loan/principal)             |
|                                       |
|                                       |
|                                       |
*********************************************************************************


Subsituting the variable names:

    nomrate = 3.95%
    r = nomrate/1200
    k = 1/(1+r)
=>  k = 0.996719133

    PV = 2,000,000
    a = 15,083.72
=>  x = 174.515769

Thus, with an annuity of 15,083.72, the present value is 2,000,000 if the loan runs 174.515769 terms/payments.
 

As term numbers in the real world are always integers, we have to round this number down in order to be certain that the 2 million threshold is 
passed, and the interest rate thus can change.

174,515769 => 174

The number of periods in the first interval, where the loan runs with an interes rate of 3.95%, is thus 240 – 174 = 66.
We repeat this procedure with eventual subsequent intervals.



b) ANNUITY-DUE

For loans where the annuities are paid in advance, annuity-due, we make a similar derivation:

*********************************************************************************
|                                       |
|   FORMULA FOR ANNUITY-DUE:                        |
|                                       |
|                                       |
|   annuity = loan * (1 - k) / (1 - Math.pow(k,termnumber));        |
|                                       |
|                                       |
|   where                                   |
|                                       |
|                                       |
|   k = 1/(1+rate);                             |
|                                       |
|                                       |
*********************************************************************************

We use short forms of the variable names:

    a = PV * (1-k) / (1 - Math.pow(k,x))
=>  (1 - Math.pow(k,x)) = PV * (1-k) / a
=>  - Math.pow(k,x) = (PV * (1-k) / a) - 1
=>  1 - (PV * (1-k) / a) = Math.pow(k,x)


The whole left side consists of constants. We can set

    II  C = 1 – (PV * (1 – k)/a)
    I+II    C = k^x

Taking the logarithm of both sides:

    log(C) = x * log (k) 
=>  x = log(C)/ log(k) 


*********************************************************************************
|                                       |
|   TERM NUMBER FORMULA FOR ANNUITY-DUE                 |
|                                       |
|                                       |
|   terms = log(C)/ log(k)                          |
|                                       |
|                                       |
|   where:                                  |
|                                       |
|                                       |
|   k = 1/(1+rate);                             |
|                                       |
|   C = 1 – (PV * (1 – k)/a)                        |
|                                       |
|   a = annuity                             |
|                                       |
|   PV = present value (capital/loan/principal)             |
|                                       |
|                                       |
|                                       |
*********************************************************************************

NB! These two formulas don't support negative interest rate, as that would lead to a k < 1

And log(k) is not defines for negative values of 'k'.


 */


    
    var PV, k, fullannuity, C, a, remaintime, remainder;
        
    PV = upperlimit-lowerlimit;

    k = 1/(1+rate/rate_divisor);
    
    if (k < 0) return -6; // Negative interest rate not supported

    if (advance)
        {

        if (periods != 1) fullannuity = upperlimit * (1 - k) / (1 - Math.pow(k,periods));
        else return -6;// 'periods' = 1 would give divitions with zero
    
        // In order to find the correct number of periods, we must use the actually paid - rounded - annuities:

        a = roundoff(fullannuity, round_direction, round_presision);

        C = 1 - (lowerlimit * (1 - k)/a);

        remaintime = Math.log(C)/Math.log(k); 

        }
    else
        {

        if (periods != 0) fullannuity = upperlimit * (1 - k) / (k - Math.pow(k,periods+1));
        else return -6; // 'periods' = 0 would give divitions with zero
    
        // In order to find the correct number of periods, we must use the actually paid - rounded - annuities:

        a = roundoff(fullannuity, round_direction, round_presision);

        C = k - (lowerlimit * (1 - k)/a);

        remaintime = (Math.log(C) - Math.log(k))/Math.log(k);

        }


/* As the time elapsed in this interval is 'elapsed' = 'periods' minus 'remaintime', we must round 'remaintime' DOWN to 
be certain the threshold is really passed: */

    
    remaintime = Math.floor(remaintime);


    var remainder = fullannuity - a; // The differenve between the unrounded and rounded annuity


/* REMAINING PRINCIPAL


This is one of the most subtle/tricky parts of FreeLoan.

We can only pay rounded annuities. One thousandth of a cent does not exist.

The present value of the rounded payments do not exactly match the present value of the theoretical payments writtten with an 'infinite'
number of decimal fractions.

But the bank will still deduct the installment part of the annuity from the booked principal. For each term, these two values will differ.

This discrepancy will follow us through the whole computation if we apply the annuity formula directly in order to find the remaining
principal.

We find the remaining principal by:

o Computing the principal 'upperlimit_adjusted' using the rounded annuity 'annuity_true' 
o Computing 'deviation' - the difference between 'upperlimit_adjusted' and 'upperlimit' - the latter a parameter to the function
o Computing 'remainingprincipal' as the sum of the present value at the end of the interval using 'annuity_true' and the forward discounted
deviation.
    

In case the loan has a residual/ballon part that remains at the end of the loan period, the interest amount for an eventual such part of the 
loan is found in the parameter 'interest_amount_res'. It must be taken into account when rounding:

*/
    

    var fullannuityround = roundoff(fullannuity + interest_amount_res, round_direction, round_presision); // Interest on residual + annuity

    var annuity_true = fullannuityround - interest_amount_res;  // The rounded payment minus the unrounded interest amount

    var elapsed = periods - remaintime; // The number of periods it takes to pay the principal lower than 'lowerlimit'




/* We apply the annuity formula again:

annuity = principal * (1 - k) / (k - Math.pow(k,calculation_periods+1))

.. with respect to the principal:

principal = annuity * (k - Math.pow(k,calculation_periods+1))/ (1 - k) 

.. if we got an annuity-due (payment in advance) loan:

principal = annuity * (1 - Math.pow(k,calculation_periods))/ (1 - k) 

The adjusted principal, 'upperlimit_adjusted' deviates a little from 'upperlimit', as the former is computed with rounded annuities:*/


    var upperlimit_adjusted;

    if (advance) upperlimit_adjusted = annuity_true * (1 - Math.pow(k,periods))/ (1 - k);
    else upperlimit_adjusted = annuity_true * (k - Math.pow(k,periods+1))/ (1 - k);


/* We call our small deviation - the difference between the inital principal computed with rounded and unrounded payments - 'deviation': */


    var deviation = upperlimit - upperlimit_adjusted; 


/* As time passes, this initial, small error will be charged with interest and grows. At any point in time, the remainding debt will be the
present value of the rounded, ordinary payments, plus the value of the rate-incurred deviation: */


    var remainingprincipal;

    if (advance) remainingprincipal = annuity_true * (1 - Math.pow(k,remaintime))/ (1 - k) + deviation * Math.pow(1+rate/rate_divisor,elapsed-1);
    else remainingprincipal = annuity_true * (k - Math.pow(k,remaintime+1))/ (1 - k) + deviation * Math.pow(1+rate/rate_divisor,elapsed);

/* FIVE ANSWERS

We will return both the annuity and the number of periods it took to pay the loan down to 'lowerlimit' from 'upperlimit' with that
annity. We also wish to keep the new, adjusted value of the "outgoing" principal. */

    var answer = new Array(5);
    answer[0] = a;
    answer[1] = elapsed;        // The real result of the function - the number of periods it takes to pay down this segment of the loan
    answer[2] = "";         // Reserved for the fee - inserted by calling function.
    answer[3] = remainingprincipal; // The remaining principal
    answer[4] = upperlimit;     // Same as the parameter
    answer[5] = remainder;      // Cents/fractions of cents we pay too much or too little at each annuity due to rounding
    
    return answer;

/* END function intervallength() */}
























function intervallength_separate(segmentarray,step,periods_remaining,round_direction,round_presision,rate_divisor,interest_amount_res)
{

/*

WHAT THE FUNCTION DOES

The function 'intervallength_separate()' computes how many payments are needed to pay down the loan from the upper to the lower loan lomit of 
the loan segment 'step', provided all segments of the loan are served as annuity loans with different interest rates, but installments from 
all segments are only used to reduce/pay down the upper segment 'step'.

The difference from 'function intervallength()' is that the latter computes the number of payments in interecals where the interest rate
at any one time is the same for all parts of the loan. Here, in 'intervallength_separate', parallell interest rates could be used in 
different segments at the same time.

As the installments also in other segments than segment 'step' are reducing the principal, we need information about all segments.

As its result, the function returns an array with five elements: 

answer[0] = annuity;                // Rounded according to rouding rules provided as parameters.
answer[1] = number of periods;          // The number of periods it takes to pay down segment 'step'
answer[2] = "";                 // (For the periodical fee - added by calling function)
answer[3] = adusted remaining principal;    // Since the number of periods must be an integer, on misses the intended principal slightly
answer[4] = ovregrense;             // Taken from the parameter 'segmentarray'
answer[5] = rest;               // Some cents/fraction of cents that remains of the annuity after rounding

The number of periods must be an integer. This effects the the remaining principal. It is computed and returned in answert[3]
Terminbeløpet inneholder ikke termingebyr, da termingebyret ikke påvirker hovedstolen i bankens regnskap.

Terminbeløpet avrundes etter regler gitt ved funksjonens parametere 'round_direction', 'round_presision' og 'rate_divisor'.


PARAMETERS: 

'segmentarray' is a matrix with one row for each segment of the loan. Each segment, for instance segment 'x', have these values:
'segmentarray': En matrise med en rad for hvert segment. Hvert segment, her segment 'x', har verdiene:

    segmentarray[x][1]  -> OBLIGATORY: Lower limt for the principal in the segment.
    segmentarray[x][2]  -> OBLIGATORY: Upper limt for the principal in the segment.
    segmentarray[x][3]  -> The periodical fee in the segment
    segmentarray[x][4]  -> OBLIGATORY: The interest rate in the segment in percent. 6,3% per anno -> 6,3 


    Det øverste/siste/dyreste segmentet skal ligge sist - med høyest plassnummer - i 'segmentarray'.

    'step'          -> OBLIGATORY: Index for the segment we are computing the number of payment periods for
    'periods_remaining' -> OBLIGATORY: Number of payment periods remaing of the whole loan.
    'round_direction,   0, 'false' or omitted: Annuities are rounded after normal rules  1: Rounded up 2. Rounded down
    'round_presision,   0, 'false' or omitted: Payment rounded to nearest 1/100 1: Rounded to nearest integer
    'rate_divisor:'     Factor we devide the annual percentage interest rate by to obtain the periodical decimal fraction rate..




METHOD


We search for the number of periodic payment  - 'periods' - neccesary to pay down the the principal in the segment 'step'.

At the end of 'term', while all segments of the loan run as separate annuity loans, the value of the whole loan - principal -  should be
paid down by the size of the segment 'periods'. Due to rounding, we will not precicely hit the amount.

This amount, thus, will be the sum of the installments. The sum, in other words, is known. But we don't know the part-installments in 
each segment. Hence, we cannot compute 'periods' directly. We have to do it through iterations.

We use Newton's method in order to obtaing effectiv iterations. It's described here:

http://en.wikipedia.org/wiki/Newton%27s_method

We need a guess, a start value for the number of periods we are looking for. We use the interest rates and the initial size of the segments
to compute an weighted average interest rate */


    var segment, weight;
    var weighted_rate = 0;
    var start_principal = segmentarray[step][2]-segmentarray[1][1]; // Principal in the interval at the start. (Step zero is not used).

    for (i=step;i>0;i--)    // We run through all the steps
        {

        segment = segmentarray[i][2]-segmentarray[i][1];
        weight = segment/start_principal;
        weighted_rate += segmentarray[i][4]*weight;
    
        }


/* Then we can use the function 'intervallength' to make an estimate for the number of periods it will take to pay the loan down to the 
wished size. THe estimate is done as if there were no segments, only one homogenous loan: */



    var periods;

    if (step > 1) periods = intervallength(segmentarray[step][2],weighted_rate,segmentarray[step][1],periods_remaining,round_direction,round_presision,rate_divisor,interest_amount_res)[1];

    else periods = periods_remaining;


/* If there is only one segment, the number of steps wquals the remaing number of periods for the whole loan. The function 'intervallength'
resurns an array. The number of periods ar ein element 1, that we have kept in the variable 'periods' in the sentence above.

Before we perform the iteration, we also want to compute the annity in each segment, plus a growth factor, 'k',  derived from the interest rate.



¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤
///////////////////////////////////  DERIVASJON AV 'sum avdrag' ////////////////////////////////////////////////////////////////////////////////
¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤

METHOD:

By the annuity formule, we can find out how many periods are required to pay al loan down to zero. Here, we won't neccesarily pay the loan to
zero, but to a lower limit for the segment that is given in 'segmentarray'. 

The number of periods it takes to pay the loan down to zero is in the parameter 'periods_remaining'.

We use the annuity in the intervall and compute how many periods it would take to pay the remaining loan to zero.

The difference must be the number of peroids it would take to pay down the principal to the remaining loan.

Newton's method dictates that we differentialte the function with respect to the number of periods.

We use the annuity formula:

*********************************************************************************
|                                       |
|                                       |
|   annuity = principal* (1 - k) / (k - Math.pow(k,calculation_periods+1))  |
|                                       |
|                                       |
|   where                                   |
|                                       |
|                                       |
|   k = 1/(1+rate)                              |
|                                       |
|                                       |
*********************************************************************************

We will rephrase this with respect to principal:


    principal = annuity * (k - Math.pow(k,eval(calculation_periods)+eval(1))) / (1 - k);


We want to compute how long time it would take to pay the remaining loan down to zero, and use other variable names:


    endprincipal = annuity* (k - Math.pow(k,eval(resttid)+eval(1))) / (1 - k);


During the iterations, we sum up the installments that are paid in each segment during the period. This sum is the size of the
princiapal at the beginning minus an eventual residue at the end:


    sum_installments += segment - endprincipal;

We will differetiate with respect to the time variable 'remaintime". 'segment' is a constant - the derivative of a constant is zero.
We thus consentrate on the variable 'endprincipal', which is a function of 'remaintime'


    endprincipal = annuity* (k - Math.pow(k,eval(remaintime)+eval(1))) / (1 - k);


    endprincipal = annuity* k / (1 - k)  -  annuity* Math.pow(k,eval(remaintime)+eval(1))) / (1 - k);


Differeentiation rules are on wikipedia: http://en.wikipedia.org/wiki/Differentiation_rules

The first term - annuity* k / (1 - k) - consists of constants with a derivative = 0. The other term is an exponential function.

To differentiate the expontential function: f(x) = a^x   => f'(x) = a^x * ln(a) 

In javascript, the natural logartim for a is computed with the function Math.log(a)


    endprincipal' =  - annuity* Math.pow(k,eval(remaintime)+eval(1)) * Math.log(k) / (1-k);


For a simpler expression


    comptime = eval(remaintime)+eval(1)


    endprincipal' =  - annuity* Math.pow(k,eval(comptime) * Math.log(k) / (1-k);



'endprincipal' contains the remaining principal after the period we are looking at. Installments paid in the period are 
'period_inst'. This amount is the principal at the start of eacrh period - 'startprincipal' - minus the principal at the end, 'endprincipal':


    period_inst = startprincipal - endprincipal;


As startprincipal is a constant, it "disappears" then differentiating:


    period_inst' = -endprincipal'


We subsitute for "endprincipal'" that we just computed:

    period_inst' = annuity* Math.pow(k,eval(comptime) * Math.log(k) / (1-k);

We will sum all 'period_inst'-amounts in the variable 'sum_installments'. The derived of 'sum_installments' we shall call 'angle'.


¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤
///////////////////////////////////  ITERATIONS ////////////////////////////////////////////////////////////////////////////////////////////////
¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤

*/


    var sum_installments = 0;                   // Paid installment summed over all the segments
    var sum_annuity= 0;                     // The sum of the annuities (installment and interest) in each interval
    var diff = 1;                           // The difference between computed and wanted installment sum 
    var angle = 0;                          // The sum of the differentiated functions
    var downpaid = segmentarray[step][2]-segmentarray[step][1]; // The size of this segment ('step')
    var comptime, k;

// Vi beregner først annuiteten i hvert segment, som ikke vil forandre seg gjennom iterasjonene: 

for (i=step;i>0;i--)
    {

    // The principal that is reduced through the installments in segment 'i':


        segmentarray[i][5] = segmentarray[i][2] - segmentarray[i][1];   


    // The dicounting factor used in the annuity formula (called 'k' in the expression) for segment 'i':

        
        segmentarray[i][6] = 1 / (eval(1) + eval(segmentarray[i][4] / rate_divisor));   


    // Annuity in segment 'i':


        segmentarray[i][7] = segmentarray[i][5] * (1 - segmentarray[i][6]) / (segmentarray[i][6] - Math.pow(segmentarray[i][6],eval(periods_remaining)+eval(1))); 


    // To be used in result-reporting:


        sum_annuity+= segmentarray[i][7];   

    }


/* We have already made a rough estimate over how many periods it will take to pay down the loan to a level where the segment 'step' has
been paid. We will use this value as the initial guess when searching for 'remaintime': */


    var remaintime = periods_remaining - periods;


/* 'remaintime' is the only unknown variable in the following iterations*/

    var rounds = 0;

    while (Math.abs(diff) > 0.001 && rounds<100)
        {

        sum_installments = 0;
        angle = 0;

        for (i=step;i>0;i--)
            {
        
            comptime = eval(remaintime)+eval(1);    // Help variable

            k = segmentarray[i][6];             // The discount factor of segment 'i'

            startprincipal = segmentarray[i][5];        // The principal in  segment 'i' at the start of 'periods'

            endprincipal = segmentarray[i][7] * (k - Math.pow(k,comptime)) / (1 - k); // Remaining principal at the end of 'periods'

            period_inst = startprincipal - endprincipal;    // Installment in the period 'periods' in segment 'i'

            sum_installments += period_inst;        // We sum the installments for each segment here.

            angle += segmentarray[i][7] * Math.pow(k,comptime) * Math.log(k) / (1-k); // Summing the differentiated 

            }

        /* We then compute the differnce between 'sum_installments' and the facit 'downpaid' (the principal of segment 'step'). The two shall become equal. */
    

        diff = sum_installments - downpaid;


        /* 'diff' is a function of 'remaintime'. We seek to find a 'remaintime' which makes 'diff' close to zero. Since 'downpaid' is
        a constant, the differntiated of the function 'diff' is the derived of 'sum_installments'. We have already computed the 
        differentiated of 'sum_installments'. It is commpounded in the variable 'angle'. So now, we can compute hoe much we will
        add or subtract from 'remaintime' to get 'diffæ closer to zero: */
    
    
        remaintime += -diff/angle;

        rounds++;

        }

/* THE NUMBER OF PERIODS MUST BE AN INTEGER

Our number for remaining periods after the current term is over, is so far a decimal fraction. There are noe corresponing payment stream in 
reality. Payments normally only accur at whole periods, so the answer must be an integer.

In order to compute the number of periods it takes to pay down the current segment, we subtract 'remaintimæ' from 'periods_remaining': THe 
number of periods remainig at the start of the interval minus the periods remaing at the end. 

This number must be rounded up. But to achieve this, we first round 'remaintimæ' down */


    remaintime = Math.floor(remaintime);            // Integer

    var theseperiods = periods_remaining-remaintime;    // The main function result

/* 
¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤
///////////////////////////////////  RESULT REPORTING  /////////////////////////////////////////////////////////////////////////////////////////
¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤

FIVE ANSWeRS:

We will return |both the number of periods it takes to pay down 'segment'. This is stored in  'theseperiods'. We will also return the new adusted
lower limit for the segment. Finally, we adjust for rounding. We thus return an array as function result.

REMAINING PRINCIPAL / ADJUSTED LOWER LIMIT

With several parallell segments, different parts og the loan un with separate annities. But the installment part of the annuities are subtracted
only from the current segment 'step'. In order to compute the remaining principal accurately, we have to transverse all the periods of the 
segment (the reason for this, is that every period's installment must be computes separatelt after the periodic payment is rounded. Otherwise, 
we would have used the annuity formula). 

For the segments that are not paid down in the interval, the installment part does not change through the interval. Hence, we start by 
determing the sum of these installments (if this is not the last segment, wher only the one segment is paid down). */


    var other_installment = 0;

    var other_principal = 0;

    var other_annuity = 0;

    var other_rateamount = 0;

    var segmentannuitet;

    var segmentrate;

    var segmentprincipal;

    var segmentrateamount;



    for (i=step-1;i>0;i--)
        {

        segmentannuity = segmentarray[i][7];            // The segment's annuity

        segmentrate = segmentarray[i][4] / rate_divisor;    // The segments interest rate

        segmentprincipal = segmentarray[i][5];          // The segment's initial principal

        segmentrateamount = segmentprincipal * segmentrate; // The segment's interest amount (for each payment)

        other_rateamount += segmentrateamount;          // The other segments' interest amount

        other_annuity += segmentannuity;            // The other segments' annuities

        other_installment -= segmentrateamount;         // The other segments' installments

        other_principal += segmentprincipal;            // The other segments' principal
        
        }   


    // Then we transverse all payments, compute the installment on subtract it from the principal of the segment:

    
    partprinc = segmentarray[step][2] - other_principal;    // Dette segmentets hovedstol (opprinnelige lånebeløp)

    intannuity = segmentarray[step][7] + other_annuity; // Segmentets annuitet pluss øvrige segmenters annuitet

    segmentrate = segmentarray[step][4] / rate_divisor; // Segmentets terminrente

    
    for (j=1;j<=periods;j++)
        {


        segmentrateamount = partprinc * segmentrate;        // Segmentets rentebeløp

        interest_segmentbelop = segmentrateamount + other_rateamount + interest_amount_res; // Trinnets rentebeløp

        trinnavdrag = roundoff(intannuity + interest_amount_res, round_direction, round_presision) - interest_segmentbelop; // Kunden kan bare betale avrundede annuiteter.

        partprinc -= trinnavdrag;
        
                            
        } 

    
    gjenstol = other_principal + partprinc; // Den delen av hovedstolen som ikke ble avdratt pluss resten av stolen som ble avdratt (som kan være negativ)

    var answer = new Array(5);

    answer[0] = roundoff(sum_annuity, round_direction, round_presision); // Annuiteten avrundet etter gjeldende avrundingsparametere.

    answer[1] = theseperiods; // Hovedsvaret funksjonen gir: Hvor mange terminer det tar å betale ned segmentet 'step'

    answer[2] = ""; // Reservert til termingebyret - som legges inn av kallende funksjon

    answer[3] = gjenstol;   // Gjenværende hovedstol ved slutten av lånet.

    answer[4] = segmentarray[step][2]; // "Inngående balanse" for hovedstolen

    answer[5] = sum_annuity - answer[0]; // Positivt tall: Vi har betalt for lite. Negativt: vi har betalt for myerest; 

    return answer;

/* END function intervallength_separate() */}



















/*¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤
¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤
<<<<<<< ++++|++++ >>>>>>        (END EFFECTIVE INTEREST RATE FOR ANNUITY LOANS)                 <<<<<<< ++++|++++ >>>>>>            
¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤
¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤*/


















































/*¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤
¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤
<<<<<<< ++++|++++ >>>>>>        EFFEKTIVE INTEREST RATE SERIAL LOAN                     <<<<<<< ++++|++++ >>>>>>
¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤
¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤*/




function serialLoan(
received,       // OBLIGATORY: The loan amount received by the borrower. (Due to fees, this might deviate from the principal in the bank's books).

// NEW IN VERSION 1.1.: 
firstpayment,       // PERIOD MODE: Either this first payment or 'numberofperiods' is obligatory. with 'firstpayment' >0, the number of periods are computed*)
numberofperiods,    // PAYMENT MODE: Either this loan time or 'firstpayment" is obligatory. With 'numberofperiods' > 0, the periodical payments (annuities) are computed.
// END - NEW IN VERSION 1.1.

periods_per_year,   // OBLIGATORY: In order to compute annual, effective interest rate, som connection to years must be made.
balloon,        // 0, 'false' or omitted: Zero. Integer > 0: The planned residual value of the loan ("balloon") to be paid when the loan period is over.
interestonly_periods,   // 0, 'false' or omitted: zero. Integer > 0: The initial interest-only period wanted by the borrower
round_direction,    // 0, 'false' or omitted: Annuities are rounded after normal rules  1: Rounded up 2. Rounded down
round_presision,    // 0, 'false' or omitted: Payment rounded to nearest 1/100 1: Rounded to nearest integer
remainder_handling, // 0, 'false' or omitted: The "global" residue after the loan is payed / compensated with the last payment  1: Is ignored
ignore_origination, // 0, 'false' or omitted: Origination fee added to the loan and included in the computation. 1 or true: Computation performed without origination fee *)
advance,        // 0, 'false' or omitted: 0. Annuity-immediate (interest in arrears) 1, Annuity_due (Payment in advance) **)
capitalization_freq,    // 0, 'false' or omitted: 12 (Capitalization 12 times a year). Integer>0: Any number of capitalizations per year.
interestonly_periods_max,   // 0, 'false' or omitted: 0. Integer >= 0: The maximal interest only-period offered by the bank. In years. 
fee_processing,     // 0, 'false' or omitted: 0. Number >= 0: Processing fee: A one-time fee of a fixed sum to be payed at the beginning of the loan period.  ****)
fee_document,       // 0, 'false' or omitted: 0. Number >= 0: Document preparation fee: A one-time fee of a fixed sum to be payed at the beginning of the loan period. ****)
fee_percentage,     // 0, 'false' or omitted: 0 .Number >= 0: Percentage fee: One-time fee to be payed at the beginning of the loan period computed out of the principle (gross loan). 2 = 2%. ****)
fee_period_perc,    // 0, 'false' or omitted: No percentage fee. Integer: Percentage. Loans given as a credit line have a periodical has a fee as a percentage of principal PER PERIOD 
rate_thresholds,    // 0, 'false' or omitted: No - intial interest rate is fixed for the whole loan for the whole loan period. 1 or 'true': Rate might change *****)
rate_segments,      // 0, 'false' or omitted: No - all segments of the loan has the same interes rate. 1 or 'true': Every segment might have separate interest rates. ******)
price_storage,      // OBLIGATORY: The parmeter 'price_storage' is a two-dimentional array. It must have at least one interest rate, in 'price_storage[1][4]'. 'price_storage[0]' is not expected nor used.*******)
accuracy)       // OBLIGATORY: 0: Acceptable accuray, high performance 1: Normal accuracy, normal performance 2: Very high accuracy, low performance

/* 


¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤
//////////////////////////      WHAT THE FUNCTION DOES:     ////////////////////////////////////////////////////////////////////////
¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤

The function computes effective interest rate for a serial loan. As a side product, other values that could come useful are computed too. All
results are returned in the array 'res':


res[0] -> effective annual interest rate
res[1] -> remainder
res[2] -> array with one 'j' for every single payment during the whole loan period:

    res[2][i][0]  -> The whole rounded payment for period 'i', included installment and fees. 
    res[2][i][1]  -> The installment for peroid 'i'
    res[2][i][2]  -> The fee for period 'i'

// NEW IN VERSION 1.1.: 
res[3] -> Number of periods (terms) when 'fistpayment' is given instead of 'numberofperiods'
// END - NEW IN VERSION 1.1.

The function handles three different types of loan segments:


i)      The interes rate for the whole loan is determined by the initial size of the principal when the loan is given. The rate does not 
    change during the loan period. This is the most common and the simplest model.

ii)     The interest rate for the whole loan changes when the principal passes certain thresholds (the parameter 'rate_thresholds' == true)

iii)    Separate segments of the loan have different interest rates at the same time. All installments are deducted from the uppermost segment 
    of the loan. This segment, thus, is payed dowm first. For instance, ther rate for the segment between 0 and 500,000 could be 4%, between 
    500,000 and 1,000,000 i could be 3.5% and above 1,000,000 it could be 3%. All applying at the same time. 
    (The parameter 'rate_segments' == true)



PARMETERS:

See the corresponding definitions in the main function freeLoan().


SECTIONS IN 'serialloan_effrate()':

The function consists of seven separate, numbered sections:

1)      Preparation and adaption of data
2)  Computation of all period payments and the remainder
3)      computation or the effective interest rate
4)  Result reporting



EXTERNAL FUNCTIONS USED


function roundoff()



ERROR CODES


See the definitions in the main function freeLoan().



THE PLAN

The interest rate is computed by iterations. Before performing the iterations, we need to know the size of every payment and the time on when
it is paid. When we have a loan that changes interest rate during the payment period, we could have subsequent intervals with different rates. 
The function also supports parallell interest rates. 

Hence, all the payments, rounded and placed in their respective period must be computed and stored in the array 'interval_data'.

Generally, we use the function parmeters to compute the values in 'interval_data' before we use the values in 'interval_data' to compute the 
result(s) that will be returned in the array 'res'.

// NEW IN VERSION 1.1.: 
ASSUMPTION FOR "PERIOD MODE"

In "period mode", when the first payment is known and we compute the number of periods, we assume that the first payment is the greatest of
all payments during the loan period. This would be true in all normal cases, but wrong if the interest rate increases dramatically after a
while.

// END - NEW IN VERSION 1.1.

¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤
//////////////////////////      1) PREPARATION AND ADAPTION OF DATA:              //////////////////////////////////////////////
¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤

*/

{

/* 


DATA IN A FORMAT SUITABLE FOR OUR FORMULAS:

It is mathematically correct to take all fees into consideration when computing effective interest rate. But the function also supports
the ommittance of the start/orgination fees: */
    

    var principal;

    if (ignore_origination) principal = eval(received);         
    else 
        {

        principal = (eval(received) + eval(fee_document)) * (100+fee_percentage) / 100; // What the user receives plus fees

        // Compensation for unexplained error: 'fee_processing' sometimes evaluates to 'undefined':

        if (!isNaN(eval(fee_processing))) principal +=fee_processing;

        }


// Error if the balloon is greater than the principal:


    if (balloon > principal) return -3;

    
/* Total number of calculation periods are the total number of periods, 'numberofperiods'  divided by 'periods_per_year' to find the number 
of years. We then multiply this by the capitalization frequency, 'capitalization_freq' to find the number of calculation periods.

*/

// MOVED IN VERSION 1.1.: (An error was also corrected: The 'while' statment was while (found = false) )

/* 'rate_divisor' is the divisor the nominal, annual interest rate must be divided by to obtain the periodic interest rate. For instance, a
nominal interest rate of 6% equals a nominal monthly decimal rate of 0,005 => 6/1200. */


    var rate_divisor = 100*capitalization_freq;


/* What is the upper segment n 'price_storage'? The function '.length' returns the length inclusive element zero, that is not in use. The last
element, thus, is  'element.length-1': */


    var num_segm = price_storage.length-1;  


/* Identifying the lowest segment that contains the upper loan amount limit: */

    var found = false;


    while (found == false)
        {

        if (principal > price_storage[num_segm][1] || num_segm == 1) found = true; 
        else num_segm--;

        }

// END - MOVED IN VERSION 1.1.

// NEW IN VERSION 1.1.:

var termnumber;

    if (firstpayment != "") 
        {

        /* Computing the number of periods of a serial loan is simple. It is the net loan dividied by the net
        installment. The net installment it the net first payment - 'netpayment' - minus the interest part.

        First, we must deduct fees from the payment, as these are not going towards paying off the loan: */

        var netpayment = (firstpayment * 12/capitalization_freq) - price_storage[num_segm][3] - principal*fee_period_perc/100;

        /* Then, we deduct the first interest payment. ('price_storage[1][4]' contains the first annual, nominal rate).

        If there is an initial interest-only period, the number of terms are either undetermed, or 'fistpayment' must be assumed 
        
        to mean the fist payment of the period after the interest-only period, when we are starting to pay off the loan. 

        */

        var netinstall = netpayment - price_storage[num_segm][4]/rate_divisor*principal;

        // If the net payment does not cover the interest rate, the loan cannot be payed back:

        if (netinstall < 0) return -8;

        // The number of periods are simply the principal divided on the periodical installment:

        termnumber = Math.ceil((principal - balloon) / netinstall); // Not sure if normal rounding is correct here, but..

        }               
    

    else termnumber = numberofperiods;

var calculation_periods = Math.ceil(termnumber/periods_per_year*capitalization_freq); 


//alert(netinstall+" "+price_storage[num_segm][4]/rate_divisor*principal); 
    
// END - NEW IN VERSION 1.1.


// The number of intial interest-only periods (where no installments are paid):


    var installment_grace_periods = interestonly_periods/periods_per_year*capitalization_freq; 
    

// The number of "normal" periodical payments that include installment:


    var installment_periods = calculation_periods - installment_grace_periods;  



/* 

¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤
///////////////////////////////////  2) COMPUTATION OF ALL PERIOD PAYMENTS AND THE REMAINDER    ////////////////////////////////////////////////
¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤

IN THIS SECTION:

In this section, we compute the periodic payments. In a serial loan all payments are different. If the amounts were not rounded, we could have 
used the formula for serial loans. But in the real world, we cannot pay amounts with many decimal fractions, only whole currenty units and cents.
Hence, we must compute on the basis of the rounded sums that are acutally paid. This requires transversing the loan period by period, computing
all payments separately.

Each payment normally consists of three parts:

o The interest part
o The installment part
o The fee part

In a serial loan, the installment is the same for all payments: The principal divided on the number of payment periods.

We store the values in the intermediate array 'per_pay' (for "periodical payment"). Further down, 'per_pay' is used for the computation of 
effective interest rate.

The content of 'per_pay' for period 'i' is:

pay_per[i][0]   -> The interest amount for the part of the loan for which installments are NOT paid in this period 
pay_per[i][1]   -> The interest amount for the part of the loan for which installments are paid in this period
pay_per[i][2]   -> The whole payment for this period, included installment and fees. 


Some of the computed data will be stored in sub-res, which is part of result reporting:


FOR RESULTREPORTING

When we must compute all payments anyway, we might as well return them in the function result, so that they could be used for instance
for a graph.

We want to return the whole period payment and specify the installment part and the fee part:

sub_res[i][0]   -> The whole rounded payment for period 'i', included installment and fees. 
sub_res[i][1]   -> The installment for period 'i'
sub_res[i][2]   -> The fee for period 'i'



Example: If the loan has 12 annual payments and runs for 20 years, there will be 240 different rows in 'pay_per'.



*/          


// The part of the payment that makes the principal smaller. In serial loan, the same for all periods:


    var installment;    
    

 // 'installment_periods' = 0 means only interest

        
    if (installment_periods != 0)  installment = (principal-balloon)/installment_periods;
    else installment = 0;


// Remaining principal after each installment. Before we start subtracting installments, the whole intial principal remains:


    var rem_princ = principal;

    

    if (!round_presision || round_presision == 0) pres = 100;   // Divisor indicating the requested presicion when rounding..
    else if (round_presision == 1) pres = 1;            // ..only two or zero decimal fractions in payments.





/* COMPUTING IN ADVANCE NUMBERS THAT ARE USED OFTEN: If the loan is concurrently running with different interes rates in different segments, all 
installments are still subtracted only from the uppermost, remaining segment. Hence, during the periods it takes to pay down the segment, the 
interest and fees in the other segments are the same for all periods in the interval.  In order to avoid computing this in each period, we compute 
the amounts in advance and put them in the array 'segm_int_am': 

The interest amount for the part of the loan for which installments are NOT paid in this period:

*/



    var segm_size;          // The size of the part of the principal that is in this segment

    var segm_int_am = new Array();  //  "Segment's interest amount"

    for (i = 1;i < num_segm;i++)
        {

        /* (The array 'price_storage' is a parameter to the function. See definition above).
        If the upper limit in the segment is smaller than the principal, or emtpy (which means 'unlimted' in FreeLoan): */

        if (price_storage[i][2] <= principal || price_storage[i][2] == "" || i == 1) 
            {

            /* If different interest rates are applied concurrently in different segments, the interest rate amount is computed
            with the separate segment rate: */

            if (rate_segments) 
                {

                // "Unlimited" as the upper limit means the segment size equals the principal minus the segment's lower limit: 

                if (price_storage[i][2] == "") segment = principal-price_storage[i][1];

                // Otherwise, the upper minus the lower limit:  
                else segment = price_storage[i][2]-price_storage[i][1];         

                segm_int_am[i] =  segment * price_storage[i][4]/rate_divisor;       // The interest amount of the segment

                // Adderes til tidligere beregnede rentebeløp i høyere segmenter
                if (i > 1) segm_int_am[i] += segm_int_am[i-1];              

                }
            else    
                {

                /* The same interest rate is applied for the whole remaining principal. This rate is the highest relevant segment's. 
                As the  whole loan is encompassed, we don't need to add up the segments. */
            
                if (price_storage[i][2] == "") segm_size = principal;       // "Ulimited' means the principal
                else segm_size = price_storage[i][2];               // Segment equals the upper segment limit
            
                // The segmentrate above, for the part of the loan currently serviced, is applied to the rest of the loan:

                if (i < num_segm) segm_int_am[i] = segm_size * price_storage[eval(1)+eval(i)][4]/rate_divisor;  

                // If there are no more segments, the current interest rate applies:    
                else segm_int_am[i] = segm_size[i] * price_storage[1][4]/rate_divisor;  

                }

            }
        }

    var pay_per = new Array(calculation_periods);   // Two dimentional array where we store the periodical payments. See definition above.

    var sub_res = new Array(calculation_periods);   // Two dimentional array for certain parts of the result. See definition above.

    var rem_segm = 0;       // What currently remains of the principal in the segment

    var now_segm = num_segm;    // The start segment 

    var fee_per;            // Periodic fee for the current period
    
    var paym_per;           // Payment for the current period

    var int_per;            // Interest payment for the current period

    var inst_per;           // Installment for the current period

    var adj_inst;           // When the payment is rounded, the remainder is deducted from /added to the principal.

    var first;          // The first period of the loan

// If interest should be paid in advance, we start at period zero, otherwise at period one:

    if (advance) first = 0; else first = 1;

// We traverse the whole loan, period by period:

    for (i=first;i<=calculation_periods;i++)
        {

        // 1. In what segment are we? We started at the top, and change for each principal limit we pass.


            if (now_segm > 1 && rem_princ < price_storage[now_segm][1]) now_segm--;


        // 2. Remaining principal in the segment (the part that is payed down in payment 'i'):


            if (now_segm == 1 || !rate_thresholds) rem_segm = rem_princ;            // Remaining principal in this segment 
            else rem_segm = rem_princ - price_storage[now_segm-1][2];


        // 3. The interest amount for this payment in this segment of the loan:


            pay_per[i] = new Array;

            if (!rate_thresholds) 
                {
        
                /* When the interest rate cannot change during the loan, it is determined by the rate when you took up the loan. 
                We find this rate in 'price_storage[num_segm][4]'. (The array 'price_storage' is a parameter to the function. 
                See above.). */ 

                termren = price_storage[num_segm][4]/rate_divisor;      
                pay_per[i][0] = 0;


                }
            else 
                {

            // WHen the interst rate can change during the loan, it is determined by the number of the segment we're in - 'now_segm':


                termren = price_storage[now_segm][4]/rate_divisor;


            // 4. The interest amount for the part of the loan for which installments are NOT paid in this period:

    
                if (now_segm > 1) pay_per[i][0] = segm_int_am[now_segm-1];      
                else pay_per[i][0] = 0;

        
                }


            pay_per[i][1] = rem_segm * termren; //   The interest amount for the part of the loan for which installments ARE paid in this period


        /* The total interest amount for this period. In a loan with interest paid in advance, there is no interest payment in 
        the very last payment: */


            if (advance && i == calculation_periods) int_per = 0; else int_per = pay_per[i][0] + pay_per[i][1];


        /* 5. Then we are ready to compute the periodical payment, including the period's installment:

        Firstly, period zero exists only in interest-in-advance loans. The way we have defined it, there is not installment (payoff of 
        the capital) in period zero: */


            if (i==0) inst_per = 0; else inst_per = installment;


        // Secondly, if we are not in an interest-only period..         


            if (i > installment_grace_periods) paym_per = int_per + inst_per;
    

        // .. interest-only period:


            else paym_per = int_per;    
                    

        // 6. We add the periodical fee (the segment's fee is used):


            fee_per = price_storage[now_segm][3];


        /* For certain loans, there is a fee as a percentage of the borrowing limit. Here, we interpret this as a percentage of the intial 
        principal: */   


            fee_per += fee_period_perc * principal;


            paym_per += fee_per;

    
        /* 7. Rounding


        The periodic payment is rounded according to the rules given as parameters to the function: 'round_direction' og (via 'pres') 
        'round_presision':*/

    
            if (round_direction == 0) pay_per[i][2] = Math.round(paym_per * pres) / pres;   // Normal rounding
            else
            if (round_direction == 1) pay_per[i][2] = Math.ceil(paym_per * pres) / pres;    // Rounded up
            else
            if (round_direction == 2) pay_per[i][2] = Math.floor(paym_per * pres) / pres;   // Rounded down


        /* The remainder of the periodic payment after rounding is added to / subtracted from the principal: */

            adj_inst = pay_per[i][2] - int_per - fee_per; // Adjusted installment after rounding.



        /* 8. The remaining principal.

        We subtract the installment part of the payment from the remaining principal:*/


            rem_princ -= adj_inst;


        // For result reporting:

            sub_res[i] = new Array();
            sub_res[i][0] = pay_per[i][2];      // The whole rounded payment for period 'i', included installment and fees. 
            sub_res[i][1] = adj_inst;       // The installment for peroid 'i'
            sub_res[i][2] = fee_per;        // The fee for period 'i'
            
    
        }



    /* When all periods are paid, the remaining principal contains the compounded rounding errors and an eventual residual/balloon payment.
    For rounding purposes, We add the last ordinary payment and the ramaining principal, round them and subtract the ordinary payment again to
    find the remaining principal: */


        var remainder;

        if (remainder_handling == 0) remainder = Math.round((rem_princ + paym_per) * pres)/pres - pay_per[calculation_periods][2];


    // If reminader_handling != 0 the compounded rounding errors are ignored:


        else remainder = Math.round((eval(balloon) + paym_per) * pres)/pres - pay_per[calculation_periods][2];


// if (Math.round(sub_res[1][0]) == 26750) alert(remainder+" "+termnumber+" "+calculation_periods);
/* 

¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤
///////////////////////////////////  3) COMPUTATION OF EFFECTIVE INTEREST RATE   ///////////////////////////////////////////////////////////////
¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤

The effective interest rate does not transpire directly through a formula. I must be found through repeated guesses, where you try to move your
guess closer to the answer for each iteration.

The best algorithm is Newton's method:

Newton's method is well described in Wikipedia: http://en.wikipedia.org/wiki/Newton%27s_method

Where 'PV' is the present value and 'k' a growth/discount factor, Newton's method regards the problem as finding the point where the function 
graph in the PV/k space crosses the 'k'-line. At the point for our guess, the tangent to the graph points in approximately the right direction, 
says Newton.

But to find the gradient of the tangent, we must differentiate the function. Because we have rounded payments, we can't use the function for 
serial loans. Hence, we don't have a function to differentiate. So we do the second best, we use the s e c a n t. 

We select at point close to 'k' as the second point where the secant line intersects the graph. If these two points are very close, the secant will 
have approximately the same gradient as the tangent.

Testing indicates that the number of iterations are about the same as when applying Newton's method. 

4-5 guesses are normally sufficient to achieve an accuracy of ten decimal fractions.


As our first guess for the growth factor 'k', we will use the nominal interest rate in the lowest segment, segment 1. To convert to decimal 
rate, we divide by 100. We add 1 to obtain a growth factor, and compute the n'th root of this factor, n being the number of capitalisations 
annually: */



    var s = Math.pow(eval(price_storage[1][4]/100)+eval(1),1/capitalization_freq)-1;
    


// From the rate 's', we compute our first guess for the discount/growth factor 'k', which is the unknown in the subsequent iterations:


    var k; 

    if (s != -1) k = 1 / (eval(1) + eval(s));   // Initiall guess: Nominal rate = effective rate
    else return -1;                 // Division by zero -> error


    var g = k - k/1000000;  // The other point where the secant crosses the graph, 'g', that is one millionth smaller than 'k' 

    var NV_round;       // The present value of the periodic payments, discounted with the best guess 'k'
    var NV_round_alt;   // The present value of the periodic payments, discounted with the marginally smaller 'g'

    var NV_rem;     // The present value of the remainder, discounted with the best guess 'k'
    var NV_rem_alt;     // The present value of the remainder, discounted with the marginally smaller 'g'

    var y;          //  'y' is the present value of all payments minus the initial principal
    var z;          // Function value close to 'y', constitutes one of the coordinates for the alternative point

    var grad;       // The gradient for the secant throught the two points y/k og z/g.

    var inc;        // The increase (increment) we give 'k' in order to get closer to result
                
    var rounds = 0;     // Counts the iterations

    /* For each iteration, we compare the present value of all our expenses with the value of what we receive. By running more
    iterations, we can get this differenve - y  - as small as we want. But accuract impairs speed, and the administator can
    choose the accuracy. From this choice, we set the maximal value of 'y' here called 'comp': */

    var comp;

    if (accuracy == 0) comp = Math.round(principal/5000);       
    else        
    if (accuracy == 1) comp = principal/50000000;

    else comp = principal/50000000000000;

    y = comp+1;     // In order for the iterations to start, 'y' must have a value greater than 'comp'


    while (Math.abs(y)>comp && rounds < 100)    // 4-5 iterations are normally enough - we limit it at 100.
        {

        // Present values are computed again in each iteration:


            NV_round = 0;       
            NV_round_alt = 0;   
            NV_rem = 0; 
            NV_rem_alt = 0;     


        // We traverse the array with all the periodic payments and compute the present value:


            for (i=first;i<=calculation_periods;i++)
                {

                        
                // The present value of the rounded periodic payment with discount factor 'k', our principal guess:


                    NV_round += pay_per[i][2] * Math.pow(k,i);      
            
            
                // The present value of the rounded periodic payment with alternative discount factor 'g':


                    NV_round_alt += pay_per[i][2] * Math.pow(g,i);  
                    
        
                }

        
// CORRECTED IN VERSION 1.1.: Corrected bug. Wrong exponent ('temnumber') was used in version 1.0.
            
        // Computing the present value of the remainder:


            NV_rem = remainder * Math.pow(k , calculation_periods);

            
        // Computing the present value of the remainder with alternative discount factor:
                

            NV_rem_alt = remainder * Math.pow(g , calculation_periods);
                        
// END - CORRECTED IN VERSION 1.1.



        /* We try to make 'y' - the differenve between the present value of all payments minus the initial principal as close to zero as
        possible: */


            y = eval( NV_round) + eval(NV_rem)   - received;
            

        // A value close to 'y', being one of the coordinates for the second slice point of the secant:


            z = eval( NV_round_alt) + eval(NV_rem_alt)   - received ;   
    
            grad = (z-y)/(g-k);     // The gradient for a line (the secant) running through the two function points 

            inc = -y/grad;          // Increment based on the secant's gradient

            k += inc;           // We increase 'k' by the increment, hoping to make 'y' closer to zero

            g = k - k/100000000000;     // We also update the value of 'g', used to make the other intersection point 
        
            rounds++;

        }


/* 


¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤
///////////////////////////////////  4) RESULT REPORTING      //////////////////////////////////////////////////////////////////////////////
¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤

e = effective periodical interest rate
er = effective annual interest rate

k = 1/ 1 + e
k (1+e) = 1
1/k = 1 + e
e = 1/k - 1

er = (((1/k)^capitalization_freqr)-1)*100

In javascript notation:

er = (Math.pow(1/k,capitalization_freq)-1)*100;

The principal function result is the effective annural interest rate. But as a bi-produkt, several other enteties are computed too. THey could
come handy in a result presentation.

They are returned in the array 'res', that has these values:

res[0] -> effective annual interest rate
res[1] -> remainder
res[2] -> array with one 'j' for every single payment during the whole loan period:

    res[2][i][0]  -> The whole rounded payment for period 'i', included installment and fees. 
    res[2][i][1]  -> The installment for peroid 'i'
    res[2][i][2]  -> The fee for period 'i'

res[3] -> The number of periods when 'period mode' was chosen.
*/  


    var er = (Math.pow(1/k,capitalization_freq)-1)*100; // Effective annual interest rate in percent

    var res = new Array(4);

    res[0] = er;    

    res[1] = remainder+" / "+rounds;

    res[2] = sub_res; //  The whole array 'sub_res' containing the values described aboce

    res[3] = termnumber;


    return res;


/* END function serialLoan() */}





























/*¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤
¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤
<<<<<<< ++++|++++ >>>>>>        (END EFFECTIVE INTEREST RATE SERIAL LOAN)                   <<<<<<< ++++|++++ >>>>>>
¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤
¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤*/









/*¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤
¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤
<<<<<<< ++++|++++ >>>>>>        (END FREELOAN)                                  <<<<<<< ++++|++++ >>>>>>
¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤
¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤*/











/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// BELOW IS THE TEST MODULE FOR FREELOAN (NOT A PART OF FREELOAN ITSELF)
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////









 

function indata_clean(streng,us_numberformat)
{
/* 
o Converts from  Norwegian/French number format to US/UK number format
o Removes blanks
*/
var innstreng = new String(streng);
var renset;
if (us_numberformat == false)
    {
 
    /* '\xn' treffer den hexadesimale karakteren 'n'. Norsk punktum har koden '2E'. '\x2E' treffer derfor norsk punktum. 
    Flagget 'g' betyr 'søk i hele strengen'. Skal det settes flagg, må søkestrengen innledes og avsluttes med '/'.
    Rekkefølgen i utbyttingen er ikke tilfeldig */
 
    renset = innstreng.replace(/\x2E/g, "");    // Replaces period/norwegian thousand delimiter (.) with nothing
    renset = renset.replace(",", ".");      // Replaces Norwegiang comma (,) with angloamerican (.)
 
    }
else renset = innstreng;
renset = renset.replace(/\s/g,"");          // '\s' matches blanks, line shift etc. 'replace(/\s/g,"")' replaced with nothing
return renset;
/* END function indata_clean() */}
 
 
 
 
 
 
 
 
 
 
 
function outdata_clean(streng,us_numberformat)
{
// Performs the opposite operations of 'indata_clean()'
var utstreng = new String(streng);
if (us_numberformat == false) return utstreng.replace(/\x2E/g, ",");    // Replaces us/uk commas with norw./french
else return utstreng;
return renset;
/* END function utdata_rens() */}






function thousandDiv(tall,us_numberformat)
{
// Divides long numbers in groups of three and plave the appropriate delimiter between the groups.
if (us_numberformat) tusenskille =",";else tusenskille = ".";
if (isNaN(tall) == false)
    {
    var tall = new String(tall);
    var lengde = tall.length;
    var nytall = "";
    while (lengde > 3)
        {
 
        nytall = tusenskille+tall.substring(lengde-3,lengde)+nytall;
        lengde = lengde-3;
 
        }
    if (lengde>0) nytall = tall.substring(0,lengde)+nytall;
    return nytall;
    }
else return tall;
/* END function thousandDiv() */}




 
////////////////// FUNCTIONS FOR QUICK-SORT: /////////////////////////////////


/* Denne elegante utgaven av Quick Sort bygger i det vesentlige på en algoritme kopiert
fra 

http://en.literateprograms.org/Quicksort_(JavaScript)?action=history&offset=20070102180347

Jeg har føyd til et par paranteser for at den skal kunne sortere matriser.

Fra 'literateprograms' er også denne lisensen:

Copyright (c) 2010 the authors listed at the following URL, and/or
the authors of referenced articles or incorporated external code:
http://en.literateprograms.org/Quicksort_(JavaScript)?action=history&offset=20070102180347
 
Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
he following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

*/




function partition(array, begin, end, pivot, kolonne)
{
    var piv=array[pivot][kolonne];  // Her er VERDIEN som skal sammenliknes
    array.swap(pivot, end-1);   // Her byttes verdiene på de to arrayplassene
    var store=begin;        // 'store' lagrer her indeksen for hvor denne delen av arrayet starter
    var ix;
    for(ix=begin; ix<end-1; ++ix) 
        {
        if(array[ix][kolonne]<=piv) 
            {       // Om veriden ved index 'ix' er mindre eller lik verdien ved index 'piv'
            array.swap(store, ix);
            ++store;
            }
        }

    array.swap(end-1, store);

    return store;

/* END function partition() */}






Array.prototype.swap=function(a, b)
{
    var tmp=this[a];
    this[a]=this[b];
    this[b]=tmp;
/* 'prototype.swap'*/}






function qsort(array, begin, end, kolonne)
{
    if(end-1>begin) {
        var pivot=begin+Math.floor(Math.random()*(end-begin));

        pivot=partition(array, begin, end, pivot, kolonne);

        qsort(array, begin, pivot, kolonne);
        qsort(array, pivot+1, end, kolonne);
    }
/* END function qsort() */}




function quick_sort(array, kolonne)
{
// 'kolonne' er den kolonnen matrisen skal sorteres etter.

qsort(array, 1, array.length, kolonne); // Den første raden - rad null - er overskrifter og skal ikke inngå i sorteringen

return array;

/* END function quick_sort() */}






////////////////// END - FUNCTIONS FOR QUICK-SORT //////////////////////////





function polediagram(data,normalize)
{
// From http://html5laboratory.com/creating-a-bar-chart-with-canvas.php

graph(data);

        function graph(data) {                          
            var graphCanvas = document.getElementById('graphSpace');
            // Ensure that the element is available within the DOM
            if (graphCanvas && graphCanvas.getContext) {
                // Open a 2D context within the canvas
                var context = graphCanvas.getContext('2d');
                context.clearRect(0,0,context.canvas.width,context.canvas.height);

                // Bar chart data
                /* var data = new Array(5);
                data[0] = "Rome,200";
                data[1] = "Dublin,120";
                data[2] = "London,80";
                data[3] = "Berlin,230";
                data[4] = "Valetta,345";*/
                
                // Draw the bar chart
                drawBarChart(context, data, 50, 100, (graphCanvas.height - 20), 50);
            }
        }
        
        // drawBarChart - draws a bar chart with the specified data
        function drawBarChart(context, data, startX, barWidth, chartHeight, markDataIncrementsIn) {
            // Draw the x and y axes
            context.lineWidth = "1.0";
            // var startY = 380;
            var startY = 480;
            drawLine(context, startX, startY, startX, 30); 
            drawLine(context, startX, startY, 570, startY);         
            context.lineWidth = "0.0";
            var maxValue = 0;
            for (var i=0; i<data.length; i++) {
                // Extract the data
                var values = data[i].split(",");
                var name = values[0];
                var height = parseInt(values[1]/normalize);
                if (parseInt(height) > parseInt(maxValue)) maxValue = height;
                // Write data to chart
                context.fillStyle = "#b90000";
                drawRectangle(context, startX + (i * barWidth) + i, (chartHeight - height), barWidth, height, true);
                // Add the column title to the x-axis
                context.textAlign = "left";
                context.fillStyle = "#000";
                context.fillText(name, startX + (i * barWidth) + i, chartHeight + 10, 200);             
            }
            // Add some data markers to the y-axis
            var numMarkers = Math.ceil(maxValue  / markDataIncrementsIn);
            context.textAlign = "right";
            context.fillStyle = "#000";

            normalizedIncrement = markDataIncrementsIn*normalize;
            normalizedValue = 0;

            var markerValue = 0;
            for (var i=0; i<numMarkers; i++) {      
                context.fillText(normalizedValue, (startX - 5), (chartHeight - markerValue), 50);
                markerValue += markDataIncrementsIn;
                
                normalizedValue += normalizedIncrement;
                
            }
        }       
        
        // drawLine - draws a line on a canvas context from the start point to the end point 
        function drawLine(contextO, startx, starty, endx, endy) {
            contextO.beginPath();
            contextO.moveTo(startx, starty);
            contextO.lineTo(endx, endy);
            contextO.closePath();
            contextO.stroke();
        }
        
        // drawRectanle - draws a rectangle on a canvas context using the dimensions specified
        function drawRectangle(contextO, x, y, w, h, fill) {            
            contextO.beginPath();
            contextO.rect(x, y, w, h);
            contextO.closePath();
            contextO.stroke();
            if (fill) contextO.fill();
        }   

/* END function polediagram() */}











function graph(nr)
{
/* Makes a graph with data from product number 'nr' */

var res = testbench(nr);

/* We shall draw using the function 'polediagram()' that requires a text array as parameter. Every element is a text where
the label and the column hight is divided by a delimiter: "Termin 0-34, 5252" 

In 'res' we now have an array like this:

res[0] -> effective annual interest rate
res[1] -> remainder
res[2][j] -> array with one 'j' for each segment that is used:
    res[2][j] = new Array();
    res[2][j][0] = interval_data[i][0];     // x'th interval's periodic payment, rounded without fee
    res[2][j][1] = interval_data[i][1];     // The number of periods the x'th interval consists of
    res[2][j][2] = interval_data[i][2]; // The periodic fee in the x'th interval
    res[2][j][3] = interval_data[i][3]; // Remaining pricipal at the end of the x'th interval (adjusted lower segment limit)
    res[2][j][4] = interval_data[i][4]; // Principal at the start of the x'th interval (upper segment lomit)

*/

var kr,i;
i = res[2].length-2; // Element zero is requires in 'polediagram()'
enhet = 1;
var data = new Array(i);
for (j=1;j<res[2].length;j++) 
    {
    kr = res[2][j][0]+res[2][j][2];
    /* The column height is maximum 500. Hence, we "normalize" the amount, so that the highest column will be approximately 500: */
    unit = Math.round(kr/5000)*10;
    if (Math.round(kr/4000)*10 > unit) unit= Math.round(kr/4000)*10;
    data[i] = res[2][j][1]+" x "+thousandDiv(Math.round(kr),false)+","+Math.round(kr);
    i--;
    }
document.getElementById("graph_heading").innerHTML = boliglansmatrise[nr][1];
polediagram(data,unit);

/* END function 'graph()*/}










function emptytozero(parameter)
{
/*In the matrix 'boliglansmatrise' data might be ruined or misrepresented. In that case, we use nil. */

if (!isNaN(parameter)) return parameter;
else if (typeof parameter === 'undefined' || typeof nr == 'undefined' || !parameter || parameter =="" || parameter ==" ") return 0;

/*END function emptytozero()*/}







function errortext(feilnr)

// NEW IN VERSION 1.1: (Added "Error code" in returned text. Added error #-8)
{if (feilnr == -1) return "Error code -1: Request for longer interest-only period than the bank offers";
else if (feilnr == -2) return "Error code -2: First loan segment not defined";
else if (feilnr == -3) return "Error code -3: balloon smaller than smallest loan offered";
else if (feilnr == -4) return "Error code -4: balloon bigger than biggest loan offered"
else if (feilnr == -5) return "Error code -5: No segment found (normally because the requested loan amount is too small or too big)";
else if (feilnr == -6) return "Error code -6: Failing convergence at zero periods or -100% nominal interest rate";
else if (feilnr == -7) return "Error code -7: Freeloan does not support the combination of separate, concurrent interest rate segments and annuities in advance.";
else if (feilnr == -8) return "Error code -8: The chosen periodic payment is too small to cover the interest on the loan.";
else if (feilnr == -9) return "Error code -9: The combination of separate, concurrent interest rate segments and user chosen periodic payment is not supported.";
// END - NEW IN VERSION 1.1.

/* END function errortext() */} 








function testbench(nr)
{
/* Testng the functions 'serialloan_effrat(e)' and 'annuityloan_effrate()' for all house loans in Finansportalen as they appear
in the external javascript array at 'http://jiffymade.com/dev/fp/boliglandata.js'


*/

// START TIMER:

var dd = new Date();
var ms1 = dd.getTime(); 

// FOR TESTING:

var refusebank = ""; 

// FOR COMPUTATION:

var i,fee_processing,fee_document,fee_percentage;
var trinn1_minbel,trinn1_maksbel,trinn1_termgeb,trinn1_nom_rente,terminsvar;
    
var remainder_handling,round_presision,round_direction,ignore_origination,received,numberofperiods,periods_per_year,interestonly_periods;
var residual,serialloan,annuity_due,rate_thresholds,rate_segments,textout,outtext,refuse,errorvalue,capitalization_freq,interestonly_periods_max;
var fee_processing, fee_document, fee_percentage, fee_period_perc, resu;


textout = new Array();
outtext = "";
refuse = 0;
errorvalue = "";

// DATA FROM USER:

received = indata_clean(document.getElementById("a").value, false);             // The net amount actually received by the borrower

// NEW IN VERSION 1.1:
firstpayment = indata_clean(document.getElementById("fp").value, false);        // First payment - this OR 'numberofperiods' must have a value, not both.
// END - NEW IN VERSION 1.1.

numberofperiods = indata_clean(document.getElementById("b").value, false);      // Number of payment periods - this OR 'firstpayment' must have a value, not both.
periods_per_year = document.getElementById("pa").value;     // How many peyment periods per year? indata_clean(streng,us_numberformat)
interestonly_periods = document.getElementById("af").value; // Number of initial periods when only interest is paid
residual = document.getElementById("sb").value;         // Part of the loan paid back in the last period
serialloan = document.getElementById("sl").selectedIndex;   // 0: Annuity loan 1: Serial loan

// In this test module, we decide the rounding rules. But normally, these must be decided in by the banks:

round_direction = document.getElementById("avre").selectedIndex;        // 0: Rounded according to normal rules. 1: Rounded up 2. Rounded down
round_presision =  document.getElementById("avpr").selectedIndex;       // 0: Rounded to nearest cend. 1: Rounded to nearest whole currency unit
remainder_handling =  document.getElementById("avpl").selectedIndex;        // 0: Remainder paid/renumerated with the last payment. 1: Remainder ignored
ignore_origination =  document.getElementById("etab").selectedIndex;        // 0: No. Orgination fees are included (as they should) 1: Yes. Ignore the fees
annuity_due = document.getElementById("f").selectedIndex;           // 0: Annuity immediate. 1: Annuity due (Correspondingly for serial loans)
            

rate_thresholds = document.getElementById("tr_ski").selectedIndex;      // 0: Rate never changes 1: Rate changes at certain thresholds.     
rate_segments = document.getElementById("tr_sep").selectedIndex;        // 0: Different rates cannot run concurrently in different segments 1: They can

var accuracy = document.getElementById("acc").selectedIndex;            // FOR ADMINISTRATOR 0: Fast, inaccurate 1: Normal 2: Extremely accurate


// PLAYING WITH 'CANVAS' IN HTML5:

var start,stop,graph,first;

// If the parameter 'nr' is missing, all loans shall be computed:

if (!nr || typeof nr === "undefined") 
    {

    start = 1;
    var stop = boliglansmatrise.length;
    graph = false;
    }

else
// If the parameter 'nr' is an integer, only this loan shall be computed:
    {

    start = nr;
    stop = eval(nr) + eval(1);
    graph = true;

    }

var tell = 1; // Not all products make it to the result list. Hence, the list has its own counter.

/* When interest is paid in advance, the first payment is in period zero. (This applies only to serial loans, where we have
computed every single payment of the loan */

if (!serialloan && annuity_due && rate_segments)
    {
    alert("The combination of separate, concurrent interest rates, annuity loan and annuity-due is not supported.");
    return "";

    }


if (annuity_due) first = 0;else first = 1;
resultAsJSON = "[";
for (i=start;i<stop;i++)
    {

    // DATA FROM THE LOAN DATA BASE 'boliglandata.js':
    
    capitalization_freq = 12 / emptytozero(boliglansmatrise[i][6]);     // The number of capitalizations every year
    interestonly_periods_max = emptytozero(boliglansmatrise[i][7])*12;  // The price list in Finansportalen uses whole years. FreeLoan period lengths at your choice.
    fee_processing = emptytozero(boliglansmatrise[i][8]);           // Processing fee - fixed
    fee_document = emptytozero(boliglansmatrise[i][9]/100*100);     // Document fee - fixed
    fee_percentage = emptytozero(0);                    // Origination fee as a percentage of the initial principal
    fee_period_perc = emptytozero(boliglansmatrise[i][11]);         // A periodic fee as a percentage of the inintial principal (the size of the loan facility)
    resu = new Array();                         // The external funcions return the resultS as an array 



    /* The interest rate functions handle a rate ladder with as many steps/segments we wish. Every step has four elements: The minimum 
    threshold for the step (lower limit), the maximum threshold, the periodical fee and the nominal interest rate in the segment.

    In this test version, we use the current format of Finansportalen.no, that only allows a maximum of five interest rate segments.

    We read these step data from the array 'boliglansmatrise', in the external file 'boliglandata.js', where we find them from element 11, 
    and put them into the array 'price_storage':*/

    resu[i] = new Array();  
    var price_storage = new Array();    
    for (j=1;j<=5;j++)  // Finansportalen currently has maksimum five steps, althoug freeLoan allows an unlimited number
        {   
        if (boliglansmatrise[i][eval(7)+(j*4)+eval(4)] !="")    // If there is an interest rate for the segment
            {

            price_storage[j] = new Array(4);
            price_storage[j][1] = boliglansmatrise[i][eval(7)+(j*4)+eval(1)];   // Minimum limit for the segment
            price_storage[j][2] = boliglansmatrise[i][eval(7)+(j*4)+eval(2)];   // Maximum limit for the segment


            if (price_storage[j][2] == "Ubegrenset") price_storage[j][2] = "Unlimited";// Freeloan speaks English:(


            price_storage[j][3] = boliglansmatrise[i][eval(7)+(j*4)+eval(3)];   // Periodic fee in the segment

            if (price_storage[j][3] == "") price_storage[j][3] = 0;         // .. it must be a number..

            price_storage[j][4] = boliglansmatrise[i][eval(7)+(j*4)+eval(4)];   // Nominal interest rate in the segment

            /* DIRTY TRICK: ADJUSTMENT OF ADJACENT INTERVALS: In Finansportalen, the tradition dictates that interest rate
            segments are reported with a gap between them. Segment one might be the interval 0 - 999.999 and the next
            1.000.000 - 1.999.999. The gap will produce a small error when computing the interest rate. Hence, we "correct"
            the upper limt to the lower loimt in the next segment: */

            if (j>1 && (price_storage[j-1][2] || price_storage[j][1])) price_storage[j-1][2] = price_storage[j][1];


            }       
        }


    if (!ignore_origination) principal = eval(received)+eval(fee_processing)+eval(fee_document)+eval(fee_percentage * (eval(received)+eval(fee_processing)+eval(fee_document)));
    else principal = received;


    if (price_storage[1][1] <= principal)   // I the loan the user requests is not smaller than the lower limit for this loan
        {   
        
        /* Even if the lowest allowed loan is for instance 500.000, the loan will still normally be paid down to a lower amount
        during the payment period. The minimum limt only applies to a new loan. But what interest rate applies then?

        We presuppose that this is the same as the rate for the lowest segment. Consequently, for computation purposes, we
        adjust the lowest limit to zero: */

        if (price_storage[1][1] > 0) price_storage[1][1] = 0;

        // HERE, THE FREELOAN FUNCTION IS CALLED:

        // NEW IN VERSION 1.1: (parameter 'firstpayment' added)
        resu = freeLoan(received,firstpayment,numberofperiods,periods_per_year,serialloan,residual,interestonly_periods,round_direction,round_presision,remainder_handling,ignore_origination,annuity_due,capitalization_freq,interestonly_periods_max,fee_processing,fee_document,fee_percentage,fee_period_perc,rate_thresholds,rate_segments,price_storage,accuracy) 
        // END - NEW IN VERSION 1.1.
        
        // If this is only the computation of a single loan, we don't proceed to make a list:
        if (graph) return resu;

        /*
        Both 'serialloan_effrate()' and 'annuityloan_effrate()' return an array as the function result.

        ANNUITIES: The content of the result array 'resu' when returned from 'annuityloan_effrate()':

        resu[0] -> effective annual interest rate
        resu[1] -> remainder
        resu[2][j] -> array with one 'j' for each segment that is used:

        
            res[2][j] = new Array();
            res[2][j][0] = interval_data[i][0];     // x'th interval's periodic payment, rounded without fee
            res[2][j][1] = interval_data[i][1];     // The number of periods the x'th interval consists of
            res[2][j][2] = interval_data[i][2]; // The periodic fee in the x'th interval
            res[2][j][3] = interval_data[i][3]; // Remaining pricipal at the end of the x'th interval (adjusted lower segment limit)
            res[2][j][4] = interval_data[i][4]; // Principal at the start of the x'th interval (upper segment lomit)



        // NEW IN VERSION 1.1:
        resu[3] -> The number of periods, when this, rather than the annuity, is computed
        // END - NEW IN VERSION 1.1.

        SERIAL: The definition of 'resu' as returned from 'serialloan_effrate()':

        resu[0] -> effective annual interest rate
        resu[1] -> remainder
        resu[2] -> array with one 'j' for every single payment during the whole loan period:


            resu[2][i][0]   -> The interest amount for the part of the capital that is NOT payed off in the period 
            resu[2][i][1]   -> The interest amount for the part of the capital that IS payed off in the period
            resu[2][i][2]   -> The whole periodic payment, installment ant periodical fee included 
            resu[2][i][3]   -> The remainder for this payment

        resu[3] -> Installment (the same amount in every payment during the whole installment period).
    
        */

        
        if (Array.isArray(resu))    // Error values are returned as a simple string, genuine results as arrays
            {

            textout[tell] = new Array();            // THere will be a list
            textout[tell][0] = boliglansmatrise[i][1];  // Bank name
            textout[tell][1] = "<a href="+boliglansmatrise[i][0]+" title='Click for details'>"+boliglansmatrise[i][3]+"</a>"; // Url to Finansportalen details

            if (capitalization_freq !=12)
                {
                if (capitalization_freq == 4) textout[tell][1] += " (quarterly capitalization)";
                else if (capitalization_freq == 2) textout[tell][1] += " (half-yearly capitalization)";
                else if (capitalization_freq == 1) textout[tell][1] += " (annualy capitalization)";
                else if (capitalization_freq == 3) textout[tell][1] += " (4-monthly capitalization)";

                }

            /* DEVIATING CAPITALIZATION: Here, we presuppose full payment at the capitalization periods. Otherwise, there might be too few periodical fees.
            
            When reporting the first payment, it will be in posistion zero for a serial loan with interest paid in advance. For annuity loans, we have
            computed eventual segments "backwords" so the first payment is in the last array element used - element 'resu[2].length-1'.

            */

            // NEW IN VERSION 1.1: 
            if (firstpayment > 0) textout[tell][2] = resu[3]; // The number of periods, rather then the first payment, were computed.
            else
            // END - NEW IN VERSION 1.1.

            if (serialloan) textout[tell][2] = thousandDiv(outdata_clean(resu[2][first][0],false));     // First payment serial loan
            else                                                // First payment annuity loan
                {

                //The annuity for the first term is in the last array row used. But under certain conditions, it could be emtpy. 
 
                bb = resu[2].length-1;  // First payment annuity loan is normally always in 'resu[2][1]'

                while (!(bb in resu[2]) || isNaN(resu[2][bb][0]) && bb>1) bb--;                 

                textout[tell][2] = thousandDiv(outdata_clean((resu[2][bb][0]+resu[2][bb][2]),false));               


                }



            textout[tell][3] = resu[0];     // Effekctive annual interest rate (THE MAIN RESULT OF FREELOAN)
            textout[tell][4] = i;       // Reference to row number in the array 'boliglansmatrise'      
            textout[tell][5] = resu[1];     // The "global remainder": Ballon plus rounding "error"

        
            tell++;

            }
        else 
            {
            errorvalue += "<br>"+errortext(resu);

            // NEW IN VERSION 1.1: (Improvement unrelated to periodic payment)
            errorvalue += " (Product: "+boliglansmatrise[i][1]+" "+boliglansmatrise[i][3]+")";
            // END - NEW IN VERSION 1.1.

            if (resu == -1) errorvalue += " Max. offered interste-only periods: "+interestonly_periods_max+ " Requested interest-only periods: "+interestonly_periods+")";
            else if (resu == -3) errorvalue += " Requested residual: "+residual+". Maximal loan: "+price_storage[price_storage.length-1][2]+")";
            else if (resu == -5) errorvalue += " Requested loan "+received+". Maximal loan: "+price_storage[price_storage.length-1][2]+")";
            }
        
        }
        else 
        {
        refuse++;
        if(refuse == 17) {
            // just for breakpoint because of invalid input data
            sdfs =1;
        }
        refusebank+="Bank "+refuse+" "+boliglansmatrise[i][1]+" "+boliglansmatrise[i][3]+"<br>";
        }
    }


resultAsJSON = resultAsJSON.slice(0,-2);
resultAsJSON += "]";
console.log(resultAsJSON);

// STOP TIMER:

var dd = new Date();
var ms2 = dd.getTime(); 
var timetext,reporttext;

timetext = "(Time used to traverse the "+boliglansmatrise.length+" loans in the list was "+(ms2-ms1)+" milliseconds)<br>";

reporttext = "A total of "+boliglansmatrise.length+" products were detected, of which "+tell+" are in the main list above. "+refuse+" did not offer the loan sum and the following gave errors: "+errorvalue;

// NEW IN VERSION 1.1: 
if (firstpayment > 0) textout[0] = new Array("<b>Provider</b>","<b>Product name</b>","<b>Periods</b>","<b>Effective interest rate</b>");
else textout[0] = new Array("<b>Provider</b>","<b>Product name</b>","<b>First payment</b>","<b>Effective interest rate</b>");
// END - NEW IN VERSION 1.1.

textout = quick_sort(textout, 3);

outtext = "<table>";



outtext += "<tr><td>"+textout[0][0]+"</td><td>"+textout[0][1]+"</td><td align=right>"+textout[0][2]+"</td><td>"+textout[0][3]+"</td><td><b>Click for graph</b></td><td><b>Residual / Iterations</b></td></tr>";

for (i=1;i<textout.length;i++) outtext += "<tr><td>"+textout[i][0]+"</td><td>"+textout[i][1]+"</td><td align=right>"+textout[i][2]+"</td><td>"+outdata_clean(Math.round(textout[i][3]*100000000000000000)/100000000000000000, false)+"</td><td><a href=javascript:void(0) onClick=graph("+textout[i][4]+")>Graph</a></td><td>"+textout[i][5]+"</td></tr>";

outtext += "</table>";

document.getElementById('allediv').innerHTML = timetext+"<br>"+outtext+"<br>"+reporttext;


/* END function testbench() */}





function getSerialResultJSON(result) {
    var JSONresult = {
            effectiveInterestRate: result[0],
            resitude: result[1],
            paybackPeriodCount: result[3],
            periods: []
    };
    
    for(var i = 1; i < result[2].length; i++) {
        JSONresult.periods[i] = {
                serPayment: result[2][i][0],
                serInstallment: result[2][i][1],
                serFee: result[2][i][2]
        }
    }
    
    return JSON.stringify(JSONresult) + ",\n";
}

function getErrorResultJSON(num) {
    return JSON.stringify({error: num}) + ",\n";
}



function getAnnuityResultJSON(result) {
    var JSONresult;
    
    
    if(!isNaN(result)) {
        JSONresult = {
                error: result
        };
    } else {
        JSONresult = {
                error: 0,
                effectiveInterestRate: result[0],
                resitude: result[1],
                paybackPeriodCount: result[3],
                periods: []
        };
        
        
        for(var i = 1; i < result[2].length; i++) {
            if(result[2][i] == undefined) {
                JSONresult.periods[i] = null;
            } else if (result[2][i][0] != undefined) {
                JSONresult.periods[i] = {
                        annPayment: result[2][i][0],
                        annNumberOfTerms: result[2][i][1],
                        annPeriodicFee: result[2][i][2],
                        annLowerSegmentLimit: result[2][i][3],
                        annUpperSegmentLimit: result[2][i][4],
                        annRemainder: result[2][i][5]
                }
            } else {
                JSONresult.periods[i] = {
                        annPayment: 0,
                        annNumberOfTerms: 0,
                        annPeriodicFee: 0,
                        annLowerSegmentLimit: 0,
                        annUpperSegmentLimit: 0,
                        annRemainder: 0
                }
            }
        }
    }
    
    return JSON.stringify(JSONresult) + ",\n";
    
}




function dis(active, passive)
{
if (active.value != "") document.getElementById(passive).value = "";
/*END dis()*/}








 -->
</script>
<style>
body {font-family: arial; font-size: 9pt}
table {font-size: 9pt}
h2 {font-size: 16pt}
input[type="button"] {width: 350px}
input[type="text"] {width: 220pt; text-align:right}
.gul {background: #ffff99}
.ros  {background: #99ffff}
#graphSpace { margin-left:80px; }
</style>
</head>
<body>
<h2>FreeLoan test module</h2>
Yellow fields for the user, the other fields for the bank.<br>
<a href="http://jiffymade.com/dev/fp/lag_boliglan_data.php">Refresh house loan data</a> (takes a few seconds).&nbsp;<a href="http://www.jiffymade.com/dev/fp/freeLoan_short.docx">Short documentation</a>&nbsp;&nbsp;<a href="http://www.jiffymade.com/dev/fp/freeLoan_long.docx">Long documentation</a><br><br>

<br>
<table>
<tbody><tr class="gul"><td>Loan amount </td><td><input id="a" value="1500000" type="text"></td></tr>
<tr class="gul" title="0/blank/false OR positive integer"><td>Residue / balloon</td><td><input id="sb" value="0" type="text"></td></tr>
<tr class="gul"><td>Number of periods </td><td><input id="b" value="240" onchange="dis(this,'fp')" type="text"></td></tr>
<tr class="gul"><td>OR first payment </td><td><input id="fp" onchange="dis(this,'b')" type="text"></td></tr>
<tr class="gul"><td>Payments per year </td><td><input id="pa" value="12" type="text"></td></tr>
<tr class="gul" title="0/blank/false = No interest-free period, Integer = Number of initial (leading) interest-only periods"><td>Interest-only periods </td><td><input id="af" value="0" type="text" width="350"></td></tr>
<tr class="gul"><td>Serial loan</td><td><select id="sl" style="{width: 220pt;}"><option selected="selected" value="0">Annuity loan</option><option value="1">Serial loan</option></select></td></tr>
<tr class="gul"><td>Immediate / due </td><td><select id="f" style="{width: 220pt;}"><option selected="selected" value="0">Payment immediate (at the end of periods)</option><option value="1">Payment due (at the beginning of periods)</option></select></td></tr>
<tr><td>Rounding direction </td><td><select id="avre" style="{width: 350pt;}"><option selected="selected" value="0">Payments rounded according to normal rounding rules</option><option value="1">Payments are rounded up</option><option value="2">Payments are rounded down</option></select></td></tr>
<tr><td>Rounding precision </td><td><select id="avpr" style="{width: 350pt;}"><option selected="selected" value="0">Payments rounded to nearest cent</option><option value="1">Payments rounded to nearest currency unit</option></select></td></tr>
<tr><td>Placement of remainder </td><td><select id="avpl" style="{width: 350pt;}"><option selected="selected" value="0">Payed / renumerated with the last payment</option><option value="1">Ignored</option></select></td></tr>
<tr><td>Treatment of origination fees </td><td><select id="etab" style="{width: 350pt;}"><option selected="selected" value="0">Fees added to the loan</option><option value="1">Fees ignored</option></select></td></tr>
<tr><td>Rate can change during the loan period? </td><td><select id="tr_ski" style="{width: 350pt;}"><option selected="selected" value="0">No: One and the same rate throughout the loan period</option><option value="1">Yes: The rate can change at certain principal thresholds</option></select></td></tr>
<tr><td>Parallell loan segments with separate rates? </td><td><select id="tr_sep" style="{width: 350pt;}"><option selected="selected" value="0">No: Only one interest rate in each period</option><option value="1">Yes, there could be several rates at the same time, one in each segment</option></select></td></tr>
<tr class="ros"><td>FOR ADMINISTRATOR: Accuracy for serial loans </td><td><select id="acc" title="The serial loan module is slow. When traffic is high, accuracy could be traded for speed" style="{width: 350pt;}"><option value="0">Low: Normally correct to the cent, fast</option><option selected="selected" value="1">Normal: Correct to ten decimal fractions, medium fast</option><option value="2">High: Correct to 15 decimal fractions, could be slow</option></select></td></tr>

</tbody></table>
<input onclick="onClick=testbench()" value="Compute" type="button">
<br>
<!--input type=button value="Vis bare lån med trapperente" onClick=testbench(-1)-->
<br>
<div id="allediv">
</div>

    <article>
        <h1 id="graph_heading"></h1>        
        <canvas id="graphSpace" width="800" height="500"></canvas>      
    </article>


</body></html>